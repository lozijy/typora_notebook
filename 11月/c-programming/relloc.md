```c
void* realloc(void* memblock, size_t size)
```

解析
1.如果p指向的空间之后有足够的空间可以追加，则直接追加，返回的是p原来的起始地址。
2.如果p指向的空间之后没有足够的空间可以追加，则realloc函数会重新找一个新的内存区域，重新开辟一块40个字节的动态内存空间，并且把原来内存空间的数据拷贝回来，释放旧的内存空间还给操作系统，最后返回新开辟的内存空间的起始地址。
3.我们需要用一个新的指针变量来接收realloc的返回值。
4.同时我们要考虑调整内存大小失败的情况，如果开辟失败，我们至少不能让原内存数据失效，我们也要释放原内存数据，并把指针置为空。
5.开辟成功，也不用担心原来的内存有没有浪费，因为realloc函数会把原来的内存空间拷贝回来，再将其内存释放。注意如果ptr!=NULL p=ptr;这个p指针已经被赋为ptr了（就不用考虑原内存空间的指针有没有被置为空指针），所以新空间不再使用时，也要释放内存，并把指针置为空。
6.realloc函数也可以具有与malloc函数相同的功能