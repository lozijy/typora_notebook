## 第一章 计算机系统漫游

综合来看，讲述了一个

1.helloworld是怎么编译链接成一个可执行文件

2.计算机硬件构成的基本框架

3.操作系统对系统的抽象



### helloworld

hello程序的起源是一个源程序，程序员通过编辑器创建并保存的文本文件，文件名是hello.c，实际上是由值0和1组成的位（比特）组成，8个位构成一个字节，大部分现代计算机系统使用ASCII标准表示文本字符，这说明了一个基本思想，系统的所有信息都是一串比特表示的

从源程序到可执行程序到转换是由编译器完成的

```shell
gcc -o hello hello.c
```

经历四个阶段:预处理器(cpp) hello.i, 编译器(ccl) hello.s ，汇编器(as) hello.o，链接器(ld) hello可执行目标程序

汇编语言位不同的高级语言的不同编译器提供了通用的输出语言



GNU项目

GCC是GNU项目开发出来的众多有用工具之一，GNU项目的目标是开发一个完整的类UNIX系统，目前GNU已经开发出了一个包含UNIX操作系统的所有主要部件的环境，**但内核除外,内核是由Linux项目独立发展而来的。GNU环境包括了EMACS编辑器，GCC编译器，GDB调试器，汇编器，链接器，处理二进制文件的工具和其他的一些部件**

### 系统的硬件组成

总线,I/O设备,主存，处理器，运行Hello程序的过程，高速缓存cache

总线:总线通常被设计为传送定长的字节快，现在大多数机器字长要么是4个字节，要么是8个字节

I/O设备:每个I/O设备都通过一个**控制器**或**适配器**与I.O总线相连，控制器和适配器的主要区别在于它们的封装方式，**控制器是I/O设备本身或者系统的主印制电路板，而适配器是一块插在主板插槽上的卡**

主存:从物理上来说,主存是一组DRAM(动态随机存储器)芯片组成的。从逻辑上来说，主存是一个线性的字节数组，每个字节有其唯一的地址



处理器:

处理器的核心是一个大小为一个字的存储设备(寄存器)，称为程序计数器PC,PC指向主存中某条机器语言指令。处理器从程序计数器PC指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令。ALU计算新的数据和地址值。

CPU在指令的要求下可能会执行这些操作:加载:从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。存储:从寄存器复制一个字节或一个字到主存某个位置，以覆盖这个位置上原来的内存。操作:把两个寄存器的内存复制到ALU，ALU对这两个字做算数运算并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内存。跳转:从指令本身抽取一个子并将这个字复制到PC中，以覆盖PC中原来的值。

处理器看上去是它的指令集架构的简单实现，但实际上现代处理器使用了非常复杂的技术加速程序的执行。所以我们既要学习指令集架构，也要学习微体系结构(描述处理器实际上是如何构成的)



运行Hello程序

键盘上输入./hello后，shell程序将字符逐一读入寄存器，再把它存放到内存中，敲回车后shell程序就知道我们结束了命令的输入，然后shell执行一系列指令加载可执行的Hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存中



高速缓存

处理器和主存的速度差异巨大，系统设计者采用了更小更快的存储设备，称为高速缓存存储器cache，作为暂时的集结区域，L1高速缓存容量达到数万字节，访问速度几乎和寄存器一样，L2高速缓存容量位数十万到数百万，访问时间比L1长5倍，但也比主存快5-10倍



### 操作系统管理硬件

操作系统为应用程序提供了简单一致的机制来控制复杂而通常不同的低级硬件，通过进程，虚拟内存和文件来实现这两个功能，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器，主存和I/O设备的抽象表示。

#### 进程

像hello这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这样一个程序在运行(互斥性)，进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件，并发执行是说一个进程的指令与另一个进程的指令是交错执行的。操作系统实现这种交错执行的机制叫上下文切换。

操作系统保持跟踪进程运行所需的所有状态信息，这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容，当操作系统决定把控制权从当前进程转移到某个进程时就会进行上下文切换。

例如两个并发的进程shell进程和hello进程，最开始只有shell进程在运行，当我们输入运行hello程序时，shell通过调用系统调用函数进入内核态，把控制权交给操作系统，操作系统保存shell进程的上下文，创建一个新的进程-hello进程。hello进程终止后，操作系统恢复shell进程的上下文。

上面提到的一个进程到另一个进程的转换是由操作系统内核管理的。内核是操作系统代码常驻内存的部分。当应用程序需要操作系统的某些操作时，它就执行一条特殊的系统调用(syscall)把控制权交给内核。然后内核执行被请求的操作洗并返回应用程序.

#### 线程

#### 虚拟内存

虚拟内存是一个抽象概念，为每个进程提供了一个假象，即每个进程都独占着主存，每个进程看到的内存都是一样的，即虚拟地址空间。图中所示是linux进程的虚拟地址空间，从下到上依次是

程序代码和数据

堆:程序代码和数据在进程一开始运行就指定了大小，不可变，但堆的大小可以通过malloc和free方法动态扩展和收缩

共享库:大约在地址空间中间，存放像C标准库和数学库这样的共享库的代码和数据的区域

栈:位于用户虚拟地址空间顶部，编译器用它来实现函数调用，调用一个函数栈就会增长，返回一个函数，栈就会收缩

内核虚拟内存 地址空间顶部区域是为内核保存的，不允许应用程序读写这个区域



#### 文件

每个I/O设备，包括磁盘，键盘，显示器，甚至网络都可以看作是文件，系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。

文件这个概念是强大的，对所有I/O设备进行了抽象封装，为应用程序提供了一个统一的视图，程序员不需要了解具体的磁盘技术。

#### 系统之间通过网络通信



## 第二章信息的表示和处理

## 第三章 程序的机器级表示

在汇编语言中一些通常对C语言程序员隐藏的处理器状态都是可见的

程序计数器PC，在X86-64中用%rip表示给出将要执行的下一条指令在内存中的地址

整数寄存器文件包括16个命名的位置，分别存储64位的值，这些寄存器可以存储地址或整数数据，有的寄存器用来记录重要的程序状态，而其他的寄存器可以用来保存临时变量。

条件码寄存器保存着最近执行的算数或逻辑指令的状态信息，他们用来实现控制或数据流中的条件变化。

程序内存包括:1.程序的可执行机器代码2.操作系统需要的一些信息3.用来管理过程调用和返回的运行时栈。4.用户分配的内存块

```shell
gcc -Og -S mstore.c
```

产生汇编文件mstore.S

```shell
gcc mstore.c
```

产生可执行文件

反汇编:

```shell
objdump -d mstore.o
```



gcc产生的汇编代码对我们来说有点难以理解，一方面他包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或是它是如何工作的描述

```shell
gcc -Og -S mstore.c
```

```assembly
.file "010-mstore.c"
.text
.global multstore
.type multstore ,@function
multstore:
	pushq %rbx
	movq %rdx,%rbx
	call mult2
	movq %rax,(%rbx)
	pop %rbx
	ret
	.size multistore , .-multstore
	.ident "GCC:(Ubuntu 4.8.1-2ubuntu1~12.04)4.8.1"
	.section .note.GNU-stack,“”，@progbits
```

以.开头的行都是指导汇编器和链接器工作的伪指令

对于一些应用程序，程序员必须用汇编语言来访问及其的低级特性。一种方法是用汇编代码编写整个函数，在连接阶段把她们和C函数组合起来。另一种方法是利用GCC的支持，直接在C程序中嵌入汇编代码.()使用内联汇编特性，用asm伪指令可以在C程序中包含简短的汇编代码

```shell
我们的标书是ATT格式的汇编代码(AT&T是运营贝尔实验室多年的公司)，这是GCC,OBJDUMP和其他一些我们使用的工具的默认格式。其他的一些编程工具，包括Microsoft的工具，以及来自Intel的文档，汇编语言都是intel格式的
```

### 数据格式

intel用字表示16位数据类型，称32位数叫双字(double words)，64位数为四字(quad words)

x86-63指令集包括完整的针对字节,字和双字的指令

char:字节	movb

short:字	movw

int:双字	movl

long:四字   movq
char* 四字  movq
float:单精度   movs 

double:双精度  movl

大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小,比如movb(传送字节),movw(传送字)，movl(传送双字),movq(传送四字),这不会和浮点数产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器

### 寄存器

一个x86的CPU包含一组16个存储64位值得通用目的寄存器，这些寄存器用来存储整数数据和指针，它们的名字都以%r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演变造成的最初8086中由8个16位的寄存器，即%ax到%sp,每个寄存器都有特殊用途，拓展到IA32架构时，这些寄存器也拓展到32位寄存器,标号从%eax到%esp，拓展到x86-64后，原来的寄存器拓展到64位，还额外添加了8个新的寄存器,从%r8到%r15

其中最特别的是栈指针%rsp,用来指明运行时栈的结束位置,有一组标准的编程规范控制者如何使用寄存器来管理栈，传递函数参数，从函数的返回值，以及存储局部和临时数据，我们会在3.7节讲述这些惯例

### 操作数

各种不同的操作数的可能性分为三种类型，一是立即数,第二种是寄存器，16个寄存器的1字节，2字节，4字节，8字节的一个作为操作数，第三类是内存引用，它会根据算出来的地址访问某个内存位置

操作格式:

立即数$Imm

寄存器ra   R[Ra]

存储器Imm   M[Imm]   绝对寻址

存储器(ra)   M[R[ra]]    间接寻址

存储器Imm(rb)			M[Imm+R[rb]]基址+偏移量 寻址

存储器(rb,ri)		M[R[rb]+R[ri]]  变址寻址

存储器Imm(rb,ri) M[Imm+R[rb]+R[ri ]] 变址寻址

存储器(,ri,s)  M[R[ri]*s] 比例变址寻址

存储器Imm(,ri,s) 比例变址寻址

存储器(rb,ri,s)   比例变址寻址

存储器Imm(rb,ri,s) MP[Imm+R[rb]+R[ri]*s]   比例变址寻址

### 数据传送

### 算数和逻辑操作

### 控制

### 过程

### 数组分配

### 异质的数据结构

### 在机器级程序中将控制和数据结合起来

### 浮点代码

## 第四章 处理器体系结构



