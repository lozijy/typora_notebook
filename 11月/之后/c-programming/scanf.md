#### 参数

功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。

下面给大家举个例子：

```
#include <stdio.h>int main(void){    int i;    i = 10;    printf("i = %d\n", i);    return 0;}
```

我们前面都是像这样写的，即直接给变量 i 赋一个值。但是这样写功能比较弱，因为这个值就变成一个“死值”了，它只能是 10，不可能是其他值，除非在程序中修改。很多时候我们希望这个值不是由程序员在程序中指定的，而是在程序运行的过程中由用户从键盘输入的。用户输入多少，变量i就是多少，这样程序的功能就更加灵活了。

那么如何实现在程序运行的过程中由用户从键盘输出值呢？用 scanf 即可实现：

```
# include <stdio.h>int main(void){    int i;    scanf("%d", &i);  //&i 表示变量 i 的地址，&是取地址符    printf("i = %d\n", i);    return 0;}
```

“输入控制符”和“输出控制符”是一模一样的。比如一个整型数据，通过 printf 输出时用`%d`输出，通过 scanf 输入时同样是用`%d`。

要想将程序中的 scanf 行弄明白，首先要清楚的是：我们从键盘输入的全部都是字符。比如从键盘输入 123，它表示的并不是数字 123，而是字符 '1'、字符 '2' 和字符 '3'。这是为什么呢？

操作系统内核就是这样运作的。操作系统在接收键盘数据时都将它当成字符来接收的。这时就需要用“输入控制符”将它转化一下。`%d`的含义就是要将从键盘输入的这些合法的字符转化成一个十进制数字。经过 %d 转化完之后，字符 123 就是数字 123 了。

第二个要弄清楚的是：`&`是一个取地址运算符，`&`后面加变量名表示“该变量的地址”，所以`&i`就表示变量 i 的地址。`&i`又称为“取地址i”，就相当于将数据存入以变量 i 的地址为地址的变量中。

那么以变量 i 的地址为地址的变量是哪个变量呢？就是变量 i。所以程序中 scanf 的结果就把值 123 放到变量i中。

综上所述，scanf 语句的意思就是：从键盘上输入字符 123，然后`%d`将这三个字符转化成十进制数 123，最后通过“取地址 i”找到变量 i 的地址，再将数字 123 放到以变量 i 的地址为地址的变量中，即变量 i 中，所以最终的输出结果就是`i=123`。

注意，为什么不直接说“放到变量i中”？而是说“放到以变量 i 的地址为地址的变量中”？因为这么说虽然很绕口，但是能加强对 &i 的理解，这么说更能表达 &i 的本质和内涵。很多人在学习 scanf 的时候，经常将“变量 i”和“变量 i 的地址”混淆，从而思维开始混乱，等深刻了解 &i 的含义之后就可以不那么说了。

以上是 scanf 的最简单用法，也是最常用、最基本、最重要的用法。这样通过 scanf 就可以在程序运行的过程中由用户来指定变量 i 的值，这与在程序中赋值相比较功能更强大。









问题一：“为啥我的第二个scanf( )函数自动跳过，不等待我输入就自己执行了？”
一个很简单的例子：
#include <stdio.h>
/*试图两次利用scanf()函数，先后读取整型变量a和字符型变量c*/
int main()
{
	int a;
	char c;
	scanf("%d",&a);
	scanf("%c",&c);
	printf("%d %c",a,c); 
}

解析：当我们输入：123 ↙
会发现程序会“直接”打印整数123，好像并没有给我们留下时间和空间输入字符型变量c的值（一开始我也一脸懵B？？）.
但是，经过调试（啊，万能的调试！），我们可以发现，其实整型变量c已经读入了值‘\n’，即ASCII码为10的字符——换行符;
如调试图：


实际上：
函数scanf( )从标准输入设备(键盘) 读取输入的信息，不会直接赋值给变量，而是先储存到一个缓冲区中（什么鬼？）；

当程序执行到函数scanf()时，程序会从缓冲区中读取；
如果缓冲区是空的，才会停滞，光标闪烁，等待键盘的输入.

值得注意的是，scanf()中格式字符串里：
-对于参数%d：会忽略缓冲区开头的空白符（空格、回车、制表符等）（无论有几个）；
-对于参数 %c：直接读取缓冲区的第一个字符（无论这个字符是什么）；

故，上例中：
1º 向缓冲区中输入：123\n
2º 语句scanf(“%d”,&a); 读取走了123，赋给变量a；
（缓冲区变化：123\n → \n）
3º 语句scanf(“%c”,&c);读取走了**\n，赋给变量c**；
（缓冲区变化：\n → 空白）

**注意：**程序从缓冲区读取完（即完成scanf语句的格式串的匹配）就是scanf语句结束了，语句结束了就不管缓冲区空不空了，自然程序会执行下一条的printf语句

解决方法：
1º 利用函数getchar( )吃掉回车：在scanf后接一个getchar( );

#include <stdio.h>
int main()
{
    int a;
    char c;
    scanf("%d",&a);
    getchar();/*吃掉回车*/
    scanf("%c",&c);
    printf("%d %c",a,c); 
}
2º 利用函数fflush( )清除缓冲区：如fflush(stdin);

#include <stdio.h>
int main()
{
    int a;
    char c;
    scanf("%d",&a);
    fflush(stdin);/*清除输入缓冲区*/
    scanf("%c",&c);
    printf("%d %c",a,c); 
}

问题二：“为啥在我输入数据和回车之后程序没有反应？”
——在函数scanf( )的格式字符串中加入\n的问题：
例如：
#include <stdio.h>
int main()
{
	int a;
	scanf("%d\n",&a);/*注意%d后的\n*/
	printf("%d",a);
}
这种情况下，即“如果scanf的格式匹配串末尾有**\n的话”，程序会不断地连续忽略空白符（也就是说缓冲区的空白符凭空被读取掉而又忽略走了），直到有非空白符出现在缓冲区；在这里即使我们不断输入“回车回车回车…”，也会被一直被程序忽略，缓冲区一直是空白，一直光标闪烁，等待键盘输入，造成阻塞的感觉。
故，当你输入一个整数和回车后，a的值不会立即打印**，要等再接收到一个非空白符（即非空格、回车、制表符等）的输入之后，该scanf语句才结束，接着才输出。

如图：


解释：当输入：123↙ 程序框中换行但并不打印；（即使再输入几个↙ ↙ ↙ 也会是只在程序框中换行）
继续输入：456↙ 此时换行，并且输出了刚才键入的123；