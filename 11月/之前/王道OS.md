内存管理

内存抽象:

指令

heap

free

stack

寄存器:

进程调度

中断，系统调用

### 

### cpu和处理器的关系

cpu就是处理器

### 

### 什么是多核，什么是多处理器

核(core)是cpu最重要的部分，cpu中间突出的芯片就是核，由硅制作

cpu，处理器

### 

### 计算机系统的体系结构

单处理器

多处理器

- 多核：性能优于多个单核处理器，因为多个处理器会发生竞争等问题

集群lan，web

### 寄存器分类

分类

通用寄存器:

专用寄存器: 指令寄存器，地址寄存器:防止进程在内存中的地址 数据寄存器,

内存:

外存:

作业池



### 操作系统的结构

内核

### 操作系统的运行机制

两种运行状态，核心态，用户态。两种运行指令，特权指令，非特权指令。两种程序，内核程序，应用程序

### 进程切换时cpu内部

寄存器保存当前运行状态，并退出运行 状态

### 中断，系统调用，异常

操作系统运行状态分为核心态和用户态，指令分为核心指令和用户指令.程序的调用和切换是通过中断完成的，进程运行结束/时间片用完/请求io操作/出现异常时，中断机制发生。操作系统由用户态切换为核心态，操作系统内核对中断发生的原因进行检查，检查完毕后重新切换会用户态

执行完每个指令后，操作系统都要检查当前是否有外部中断信号

### 一个典型的指令执行周期

cpu在内存中获取指令，存放在指令寄存器中，随后要么被解码，要么继续将内存中的数据存放在数据寄存器中

### 存储结构

CACHE 读取速度最快

RAM 读取速度中等

磁盘 读取速度最慢

cpu寄存器

内存

外存

### 计算机系统的体系结构

单处理器系统

多处理器系统

集群系统

### 操作系统结构

结构:单作业操作系统

多道批操作系统

分时系统

### 内存抽象

在真实内存中，用物理地址区分不同数据的位置，内存抽象后会将内存划分为很多个内存块.

每个代码块是这样的



stack和heap共享free的内容

内存中的地址分为 相对地址和真实地址,物理地址=相对地址+起始地址。

physical address=virtual address+base address

cpu中有基址寄存器和界限寄存器，在作业进入内存前，会自动加上基址寄存器的内容。

cpu中拥有内存管理单元MMU,专门用来对内存地址进行翻译

### 内存划分方式

单一连续存储管理

分区式存储管理

1. 固定分区
2. 动态分区

伙伴系统



# 第一章

###  中断和异常

1.作用

发生中断意味着操作系统介入，开展管理工作

**CPU收到计时部件发出的中断信号，切换为核心态对中断进行处理，控制权限给到操作系统，时间片用完了，给到进程2，控制权限给到用户程序，进程2发出系统调用(内中断信号)，此时控制权限又给到操作系统，操作系统进行I/O操作**

中断可以使操作系统从用户态转为核心态，使操作系统获得计算机控制权

用户态进入到核心态只能通过中断，**核心态进入用户态只需要把程序状态字PSW的标志位设置为用户态**

2.分类(广义)

**1.内中断 CPU内部**  

自愿中断-指令中断 系统调用时的访管指令(陷入指令，trap指令,汇编int)

强迫中断- 硬件故障 缺页 软件故障 除0

**2.外中断  CPU外部**

外设请求   I/O操作完成

人工干预	

另一种分类

1.内中断

陷阱，陷入(trap)

故障

终止

2.外中断

I/O中断

人工干预



3.外中断处理过程

一执行程序的一系列指令，每次执行完一个指令后就会检查是否有外部中断信号

**二如果检测到外部中断信号就会保护被中断进程的CPU环境(程序状态字PSW,程序计数器PC，通用寄存器)**

三**根据中断信号类型转入相应的中断处理程序(核心态)**

四恢复原进程的CPU环境并退出中断



### 系统调用

1.作用

提供给编程人员的接口函数。用户进程想使用共享资源，只能通过系统调用向操作系统发出请求，操作系统会对请求进行协调管理，保证系统的稳定性和安全性

2.分类

设备管理

文件管理

进程管理

进程通信

内存管理

2.系统调用和库函数的区别

普通应用程序其实可以直接使用汇编语言调用系统调用，但是一般的程序员都是通过库函数调用系统调用，部分库函数对系统调用进行了封装

3.系统调用的背后

高级语言中的某个函数被编译成汇编语言，汇编语言中回存在int陷入指令使操作系统进入核心态,int后面的参数指明了系统调用号

int 其实是执行陷入指令

陷入指令(int)是唯一一个只能在用户态执行，不能再核心态执行的指令

***系统调用涉及对系统资源的管理，对进程的控制，需要执行一些特权指令，因此需要在核心态下完成***

*凡是对资源进行操作的都需要通过系统调用执行，因此我们可以判断哪些操作是系统调用*

*系统调用发生在用户态，对系统调用的处理发生在核心态*

# 第二章 进程

### 进程

1.程序

程序:就是一个指令序列早期的计算机只支持单道

在内存中 内存包含了程序段和数据段，程序段放在低地址部分，数据段放在高地址部分

多道程序技术:多道程序并发进行,内存中存放着多个程序段和数据段

2.PCB和进程组成

为了方便管理，系统为每个运行的程序配置了一个数据结构pcb，用来描述进程的各种信息

PCB+数据段+程序段三部分组成了进程实体（简称进程），创建进程实际上就是创建PCB，撤销进程是撤销进程实体中的PCB

PCB是进程存在的唯一标志

3.进程定义(强调动态性)

进程是程序的一次执行过程

进程是一个程序及其数据在处理机上顺序执行时发生的活动

进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

引入进程实体后可把进行定义为:进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

严格来说，进程实体和进程并不相同，进程实体是静态的，进程是动态的，不过除非题目专门考察二者区别，否则认为二者相同，可以说"进程实体是由PCB,程序段，数据段组成"

4.PCB组成

进程的管理者(os)所需的数据都在PCB中

PCB包括

1.进程描述信息

进程标识符PID,用户标识符UID

2.进程控制和管理信息

进程当前状态，进程优先级

3.资源分配清单

程序段指针，数据段指针，键盘，鼠标

4.处理机相关信息

各种寄存器的值

5.进程的组织

一个系统中通常有数十数百个PCB，应该用适当的方式把这些PCB组织起来

进程的组成讨论的是进程内部由哪些部分构成的问题，进程的组织讨论的是多个进程间组织方式问题

链接方式 

按照进程状态把PCB分为多个队列

操作系统持有只想各个队列的指针

执行指针

就绪队列指针

阻塞队列指针

索引方式

按照进程状态的不同建立几张索引表

操作系统持有只想各个索引表的指针

执行指针

就绪表指针

阻塞表指针

6.进程的特征

动态性 进程是程序的一次执行过程，是动态产生变化消亡的

并发性

独立性 独立运行，独立获得资源，独立接受调度的基本单位

异步性 各进程按各自独立的不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题

结构性 每个操作系统都会配置一个PCB

### 进程的状态与转换

1.三种基本状态

运行态 :占有CPU并在CPU上运行

就绪态 :已经具备运行条件，但由于没有空闲CPU而暂时不能运行

阻塞态 :因等待某一事件二暂时不能运行，如等待操作系统分配打印机，等待读磁盘操作的结果

2.另外两种状态

创建态

操作系统需要完成创建进程，需要为该进程分配所需的内存空间等资源，并为其创建，初始化PCB(如分配PID)

终止态

进程运行结束(或因为BUG导致无法继续执行下去)，操作系统需要完成撤销进程相关工作，完成将分配给进程的资源回收，撤销进程PCB等工作

3.进程状态的转换

创建态-->就绪态

就绪态-->运行态

运行态-->就绪态

运行态-->阻塞态 进程用系统调用申请某种系统的资源，是进程的主动行为

阻塞态-->就绪态 不是系统自身能控制的，是一种被动行为



注意:不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态(因为就如阻塞态是进程主动要求的)

### 进程控制

1.什么是进程控制

对系统中的所有进程实施有效的管理，具有创建新进程，撤销已有进程，实现进程状态转换等功能

简单来说进程控制就是要实现进程状态转换

2.如何实现进程控制

原语实现进程控制，特点是执行期间不允许中断，一气呵成，这种不可中断操作就是原子操作

采用关中断和开中断指令实现

关中断指令--原语代码--开中断指令

关开中断的权限非常大，是只允许在核心态下执行的特权指令。

3.进程控制相关的原语

 更新PCB中的信息(修改进程状态标志，将运行环境保存在PCB，从PCB恢复运行状态)

将PCB插进合适的队列

分配回收资源

4.进程控制详细讲述

01.进程的创建

1.创建原语  创建态-->就绪态

​	申请空白PCB

​	为新进程分配所需的资源

​	初始化PCB

​	将PCB插入就绪队列

2.引起进程创建的条件

​	在分时系统中，用户登录成功，系统会为其建立一个新的进程

​	多道批处理系统中，有新的作业放入内存，会为其建立一个新的进程

​	用户向操作系统提出某些请求时，会新建一个进程处理该请求

​	由用户进程主动请求建立一个子进程

02.进程的终止

1.撤销原语  就绪态/阻塞态/运行态 -->终止态-->无

​	从PCB集合中找到终止进程的PCB

​	若进程正在运行，立即剥夺CPU，把CPU分配给其他进程

​	终止其所有子进程

​	将该进程拥有的所有资源归还给父进程或操作系统

​	删除PCB

2.引起进程终止的事件

​	正常结束

​	异常结束

​	外界干预



03.进程的阻塞

1.阻塞原语

​	找到套阻塞的进程对应的PCB

​	保护进程运行现场，把PCB状态信息设置为阻塞态，暂时停止进程运行

​	将PCB插入相应事件的等待队列

2.引起进程阻塞的条件

​	需要等待系统分配某种资源

​	需要等待相互合作的其他进程完成工作

04.进程的唤醒

1.唤醒原语

​	在对扩等待队列中找到PCB

​	把PCB从等待队列移除，设置进程为就绪态

​	将PCB插入就绪队列，等待被调度

2.引起进程唤醒的条件

​	等待的事件发生(因何事阻塞就应由何事唤醒)



05.进程的切换

1.切换原语

​	将运行环境信息存入PCB

​	PCB移入相应队列

​	选择另一个进程执行，并更新其PCB

​	根据PCB恢复新进程所需的运行环境

2.引起进程切换的事件

​	当前进程时间片到

​	有更高优先级的进程到达

​	当前进程主动阻塞

​	当前进程终止

### 进程通信

1.什么是进程通信 

进程通信就是指进程之间的信息交换，进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立

为了保证安全，一个进程不能直接访问另一个进程的地址空间

但是进程之间的信息交换是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法

三大方式 共享存储，消息传递，管道通信

2.共享存储

操作系统为两个进程提供一个共享空间，两个进程对共享空间的访问必须是互斥的(通过操作系统提供的工具实现)

操作系统只负责提供共享空间和同步互斥工具(如P，V操作)

共享存储 :基于数据结构的共享，基于存储区的共享

基于数据结构的共享:比如共享空间里只能放一个长度为10的数组，这种共享方式速度慢，限制多，是一种低级通信方式

基于存储区的共享:在内存中画出一块共享存储区，数据的形式，存放位置由进程控制，而不是操作系统，这种共享方式速度更快，是一种高级通信方式

3.管道通信

管道是指用于连续读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区(linux中的pipe是4kb大小)，管道只能采用半双工通信，某一时间段只能实现单向的传输没如果要实现双向同时通信，则需要设置两个管道

各进程要互斥地访问管道。

进程1写数据必须把管道填满后进程2才能读取数据(read被消息交换阻塞)，同样，进程2读数据读完后进程1才能写数据(write被阻塞)

以字符流的形式写入管道

数据一旦被独处，就从管道中被抛弃，这意味着读进程只能有一个，否则会有读错数据的情况

4.消息传递

进程间的数据交换以格式化的消息为单位，进程通过操作系统提供的发送消息/接收消息两个原语进行数据交换。

消息包括消息头和消息体(和计算机网络中的TCP/IP报文有点像)

消息头包括:发送进程ID,接受进程ID，消息类型没消息长度等格式化的信息



消息传递包括了直接通信方式和间接通信方式

直接通信方式:消息直接挂到接受进程的消息缓冲队列上

间接通信方式:消息先发送到中间实体(信箱)中，因此也称信箱通信方式

### 线程概念和多线程模型

1.什么是线程，为什么要引入线程

传统进程只能串行的执行一系列程序，为此引入了线程，增加并发度

传统的进程是程序执行流的最小单位

引入线程后，线程成为了程序执行流的最小单位

每个进程拥有多个线程，每个线程拥有不同的代码或相同的代码

可以把线程当做轻量级进程

线程是一个基本的cpu执行单元

引入线程后不仅是进程间可以并发，进程内的各线程间也可以并发

引入线程后，进程只作为除CPU之外的系统资源的分配单元 (如打印机，内存地址空间)



2.引入线程机制后有什么变化?

资源分配，调度:

传统的进程是资源分配，调度的基本单位

引入线程机制后，进程是资源分配的基本单位，线程是调度的基本单位

并发性:

传统进程机制中，只能进程间并发

引入线程后，各进程间也能并发，提高了并发度

系统开销:

传统的进程间并发，需要切换进程的运行环境，系统开销很大

线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

引入线程后，并发带来的系统开销减小



3.线程的属性

各个线程都有一个线程ID，线程控制块(TCB)

也有就绪阻塞运行三种基本状态

线程几乎不用有系统资源

同一进程的不同线程间共享进程的资源(IO设备，内存空间)

由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预

同一进程中的线程切换，不会引起进程切换

不同进程中的线程切换，会引起进程切换

切换同进程内的线程，系统开销很小

切换不同进程内的线程，系统开销很大



4.线程的实现方式

分为用户级线程和内核级线程



用户级线程ULT

由应用程序通过线程库实现

所有的线程管理工作都有应用程序负责(包括线程切换)

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预

在用户看来，是有多个线程，在操作系统内核看来意识不到线程的存在



内核级线程KLT

内核级线程的管理工作由操作系统内核完成。线程调度，切换由内核负责，因此必须在核心态下完成



在同时支持用户级和内核级线程的系统中，可采用二者组合的方式将n个用户级线程映射到m个内核级线程上



注意:操作系统只能看见内核级线程，所以只有内核级线程才是处理机分配的单位,比如在四核处理机上内核空间里有2个内核级线程，用户空间里有3个用户级线程，那么只能有2个核心被分配，也只能有2个线程并行执行



5.多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了多线程模型问题

多对一模型 ：多个用户级线程映射到一个内核级线程

优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点:由于内核级线程才是处理机分配的单位，一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行



一对一模型：一个用户级线程映射到一个内核级线程

优点:并发能力强,一个线程被阻塞后，别的线程还可以继续执行

缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，线程管理的成本高，开销大



多对多模型:n个用户级线程映射到m个内核级线程

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点



### 进程调度

处理机调度的概念，层次

高级调度(作业调度):按一定原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源并建立相应PCB

中级调度(内存调度):暂时调到外村等待的进程状态叫挂起状态，PCB并不会一起调到外村，而是会常驻内存,pcb会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保存对各个进程的监控，管理。被挂起的PCB会被放到挂起队列中。中级调度决定将那个处于挂起状态的进程重新调入内存。

补充:进程的挂起态和七状态模型.

注意区别挂起态和阻塞态:二者都暂时不会获得处理机资源，但是挂起态的进程映像在外存中，阻塞态的进程映像在内存中，进程映像包括了进程的PCB,数据段和程序段

七状态模型:



低级调度(进程调度):按某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度室操作系统中最基本的一种调度，在一般的操作系统中都会配置进程调度。

进程调度的频率很高，一般几十毫秒一次



#### 进程调度的时机，切换与过程，方式

1.时机

需要进程调度:

进程主动放弃处理:进程正常重视，运行发生异常而终止

进程被迫放弃处理机:分给进程的时间片用完了，有更紧急的事需要处理(如I/O中断)，有更高优先级的进程进入就绪队列

不能进程调度:内核临界区的进程，处理中断的过程，在原子操作的过程中（原语）

区别:内核临界区和普通临界区

临界资源:一个时间段内值允许一个进程使用的资源，各进程需要互斥地访问临界资源

临界区：访问临界资源的代码

内核临界区:一般用来访问某种内核数据结构的(比如进程的就绪队列)，如果一个进程还没退出内核临界区就进行进程调度，那么此时就绪对扩是被锁住的，无法进行进程调度

普通临界区:如果一个进程访问的是一个普通的临界资源(比如打印机)，在打印机完成之前，进程一直处于临界区内，临界资源不会解锁，但打印机又是慢速设备，此时如果一直不允许进程调度的话会导致CPU一直闲置

2.进程调度的方式:

抢占式:系统可以强行使进程放弃处理机资源，如果时间片分完，或有更紧急的事，或有更高优先级的进程在就绪队列中时会剥夺该进程的处理机资源。

非抢占式:进程只能主动放弃处理机资源

分时操作系统都是抢占式的调度方式

3.切换与调度的区别:

狭义的进程调度室就绪队列选中一个要运行的进程。

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

进程切换主要完成了对原来进程各种数据的保存，对新的进程各种数据的恢复(如：程序计数器，程序状态字，各种数据寄存器等处理机现场信息，这种信息一般保存在进程控制块)

注意:进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然会使整个系统的效率降低，使系统大部分时间花在进程切换上，而真正用于执行进程的时间减小。

#### 调度算法的评价指标

CPU利用率

系统吞吐量

周转时间 平均周转时间

带权周转时间 平均带权周转时间

等待时间:进程/作业等待被服务时间之和

响应时间:从用户提交请求到首次产生响应所用的时间

#### 调度算法

先来先服务FCFS

短作业优先SJF

高响应比优先HRRN

时间片轮转调度算法(RR)

优先级调度算法

多级反馈队列调度算法

### 进程同步 进程互斥



#### 进程互斥的软件实现

#### 进程互斥地硬件实现

### 信号量机制

### 死锁

## 第三章 内存管理

### 内存的基本知识

内存条的基本知识:内存是从放数据的设备，程序执行前需要先放到内存中才能被CPU处理。

多个程序并发执行，如何区分各个程序的数据放在什么地方的?内存中有一个一个的存储单元，内存地址从0开始每个地址对应一个存储单元。如果计算机按字节编址，则每个存储单元为1字节，如果字长为16位，则每个存储单元大小为1个字，字不一定是2个字节，需要看计算机的机器字长。

进程的运行原理:指令,每个进程由程序段，数据段，PCB组成，指令就存储在程序段中，指令一般用的是逻辑地址(相对地址)

源代码编译后生成一个个模块，再链接后生成装入模块(可执行文件)，再装入到内存。

装入的三种方式(三种不同的方法完成逻辑地址到物理地址的转换)

1.绝对装入

2.静态重定位

3.动态重定位

绝对装入:在编译时如果知道程序在内存的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块的地址，将程序和数据装入内存

只适用于单道程序环境,程序中使用的绝对地址，可在编译或者汇编的时候给出，也可由程序员直接赋予，通常情况下都是编译或汇编时再转换为绝对地址



静态重定位

又叫可重定位装入，编译链接后的地址都是从0开始的，指令中使用的地址，数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变换为物理地址(地址转换是在装入时由装入程序一次完成的)

特点是在一个作业装入程序时，必须分配其要求的全部内存空间，如果没有足够的内存就不能装入该作业。作业一旦进入内存后，在运行期间不能再移动，也不能再申请内存空间



动态重定位

又称动态运行时装入。编译，链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时彩进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持

重定位寄存器:存放装入模块的起始位置

允许程序在内存中移动。



链接的三种方式

1.静态链接:在程序运行前先将各目标模块及它们所需的库函数连接成一个完整的可执行文件，之后不再拆开

2.装入时动态链接:将各目标模块装入内存时，边装入边链接的链接方式

3.运行时动态链接:在程序执行中需要该目标模块时才对它进行链接，其优点是便于修改和更新，便于实现对目标模块的共享

### 内存管理的概念

1.内存空间的分配和回收

内存管理管理什么?操作系统如何记录哪些内存区域已经被分配出去了，哪些还空闲，很多位置可以放置进程，放在哪里?在进程运行结束后如何将进程占用的内存空间回收



2.内存空间的扩展

操作系统提供某种技术从逻辑上对内存空间进行扩充



3.地址转换

程序员写程序只需要关注指令数据的逻辑地址，而逻辑地址到物理地址的转换应该由操作系统负责

三种装入方式



4.内存保护

操作系统保证进程在各自的存储空间内运行互不干扰

方法一:在cpu中设置一对上下限寄存器存放进程的上下限地址，进程的指令要访问某个地址时，cpu检查是否越界

方法二:采用重定位寄存器(基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址，界地址存放的是进程的最大逻辑地址。



### 覆盖和交换

内存空间的扩充:覆盖技术，交换技术，虚拟存储技术



覆盖技术:把程序分成多个段，常用的段常驻内存，不常用的段在需要时调入内存，内存中分为一个固定区和若干覆盖区,需要的段放在固定区，不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存

需要程序员声明覆盖结构，操作系统自动完成覆盖，缺点:对用户不透明，增加了用户编程负担



交换技术:内存空间紧张时，系统把内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存(进程在内存和磁盘间动态调度),前面提到的中级调度和这个有关.

应该在外存的什么位置保存被换出的进程?什么时候应该交换?应该换出哪些进程?

1.具有对换功能的操作系统，通常把磁盘空间分为文件区和对换区两部分，文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采取离散分配方式，对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度,因此通常对换区采用连续分配方式，总之对换区的IO速度比文件区的更快，(Linux的swap区)

2.交换通常发生在有许多进程且内存吃紧时进行，而系统符合降低就暂停。例如:在发现许多进程运行时经常发生缺页，说明内存紧张，此时可以换出一些进程，如果缺页率明显下降，就可以暂停换出。

3.可优先考虑换出阻塞进程，可换出优先级低的进程，为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的

### 连续分配管理方式

## 第四章 文件管理