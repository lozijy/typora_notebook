本人致力于制作一个操作系统内核Lonux，在此之前已经自学了C语言，汇编语言，了解制作操作系统的大概流程，看过部分intel手册，但无奈对操作系统的具体理论仍然知之甚少，所以我期望通过久负盛名的MIT 6.S081实验来作为我制作操作系统的理论依据，本博客仅供学习使用，参考了github user @duguoshen的博客并进行了相应的拓展，如涉嫌侵权会自行删除.

关于6.s081的学习从24,Oct,2022开始，于xx,xx,xxx全部结束

课程分为8章，对应12个lab

课程:

1：操作系统接口:

2：操作系统架构

3：页表:

4：陷阱指令和系统调用:

5：中断和设备驱动:

6：锁

7：调度

8：文件系统

lab:

1：通过预先写好的系统调用写一些user程序.

2：自行添加拓展一些新的系统调用

3：对页表进行修改

4：使用陷阱实现系统调用

5：

## 第一章 操作系统接口

1.xv6简介

xv6模仿了Unix的内部设计

xv6采用传统的内核形式

当进程需要调用一个内核服务时，进程会调用一个系统调用，系统调用进入内核，内盒执行服务并返回，一个进程在用户空间和内核空间交替进行.下面列举了xv6所有的系统调用

2.系统接口

![image-20221025182016524](D:\AppData\Typora\typora-user-images\image-20221025182016524.png)

![image-20221025182042344](D:\AppData\Typora\typora-user-images\image-20221025182042344.png)

````shell
这是open的flags的定义:
(kernel/fcntl.h)
#define O_RDONLY  0x000		//Open for reading only
#define O_WRONLY  0x001    //Open for writing only
#define O_RDWR    0x002    // Open for reading and writing
#define O_CREATE  0x200    // Create the file with the mode permissions if file does not exist
#define O_TRUNC   0x400    //If the file exists and is a regular file, and the file is successfully opened O_RDWR or O_WRONLY, its length is truncated to 0 and the mode and owner are unchanged
````

### 其他自己调用系统接口做的函数实例

1.copy

对read接口的应用

```c
int main(){
    while(1){
        int n=read(0,buf,sizeof(buf));//默认0连接到控制台输入
        if(n<=0){
            break;
        }
        write(1,buf,n);//默认1连接到控制台输出
    }
    
    
}
```

2.open

对open接口的应用

```c
int main(){
    int fd=open("output.txt",O_WRONLY|O_CREATE);
    if(fd!=-1){write(fd,"hello",5)}//"hello是指针返回第一个字符的地址"
}
```

3. exec	

   对exec接口的应用
   
   ```c
   #include "kernel/types.h"
   #include "user/user.h"
   int main(){
   	char *args[]={"echo","this","is","echo",0};
   	exec("echo",args);
   	exit(0);
       printf("exec failed!\n")
   }
   ```
   
   
   
   4.forkexec
   
   对fork,exec的应用
   
   exec执行一个文件后,他执行的程序就会替代自身，而且不会返回自身(不会执行接下来的命令)，所以我们常常把fork和exec联合使用，这样就不会对父进程产生影响，但是对于一个比较大的程序来说,fork复制内存，又让它去exec,浪费了很多资源，我们后面会学习一个懒复制的trick..
   
   ```c
   #include "kernel/types.h"
   #include "user/user.h"
   int main(){
   	int pid,status;    
   	char *args[]={"echo","hello","forkexec",0};
   	pid=fork();
   	if(pid==0){
   	printf("child");//printf is included in the "user.h"
   	exec("echo",args);
       printf("exec failed");//if the line 9 is failed, this line will be executed
   	}else if(pid!=0){
   	printf("parent");	
       wait(&status);
       printf("the child is exit with the status %d",status);
   	}
   	exit(0);
   }
   
   
   ```
   
   5.redirect
   
   对close,open的应用
   
   大概就是close关闭一个文件描述符，再open就会顶替这个文件描述符，从而实现重定向.
   
   ```c
   #include "kernel/types.h"
   #include "user/user.h"
   
   int main(){
       int pid;
       char *args[]={"echo","hello","redirect",0};
       pid=fork();
       if(pid ==0){
           close(1);//close the current filedescripter,is the "1",not the zero!
           open("output.txt",0x201);//0_WRONLY|0_CREATE,but Ican't find the head file
           exec("echo",args);
       }else{
           wait((int *)0);
       }
       exit(0);
   }
   ```
   
   

###  进程和内存

1.fork

创建一个子进程，考虑编译后的二进制文件，子进程会完全复制这些二进制文件，在内存中，他们拥有相同的命令，数据和栈，而且他们都认为自己是从虚拟内存0开始执行的。他们都会抢占cpu资源，所以他们执行的操作通常是交叉进行的(比如说我们fork一个进程，然后打印一串字符"hello",那么就会显示如"hhellloelo"这样如同乱码的字符)。

返回:如果是父进程，就会返回0,如果是子进程就会返回pid,所以调用fork的程序我们一般要用if判断是子进程还是父进程来执行不同的操作

```c
int pid=fork();
if(pid!=0){
    pid=wait((int *)0)
    printf("parent!");
}else{
    printf("child!");
    exit(0)
}
```

2.exec

`exec系统调用使用从文件系统中存储的文件所加载的新内存映像替换调用进程的内存。

exec系统调用有两个参数,文件名和参数args,args是一个字符串数组,第一项通常是要执行的文件名，往往跳过，最后一项为0表示字符串数组已结束

例如:

```c
char* argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```



### I/O和文件描述符

1.文件描述符

文件描述符是一个小整数0,1,2and so on..,进程可以打开一个文件，目录，设备，或者创建一个管道，或复制一个已经存在的描述符来获取一个文件描述符。它会将文件，管道和设备之间的差异抽象出来，看起来都像是字节流，通过文件描述符来访问文件，操作系统并不知道它到底在向什么东西输出

进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出）

默认情况下0表示键盘获取，1表示向键盘显示,如果想要改变输入输出位置可以调用系统调用close()函数

**关于read,write,open,dup请自行查看前面的操作系统接口**

2.read创建文件描述符

```c
char buf[512];
int n;
for (;;) {
    n = read(0, buf, sizeof buf);//这里的0是文件描述符,代表键盘输入
    if (n == 0)
        break;
    if (n <= 0) {
        fprintf(2, "read error\n");
        exit(1);
    }
    if (write(1, buf, n) != n) {//这里的1是文件描述符，代表控制台输出，把控制台作为输出目的地
        fprintf(2, "write error\n");
        exit(1);
    }
}

```

3.通过open创建文件描述符

close (0)关闭了键盘输入，下一行open返回的文件描述符变成0顶替了键盘输入

```c
char* argv[2];
argv[0] = "cat";
argv[1] = 0;
if (fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);//关闭键盘输入，把input.txt作为输入
    exec("cat", argv);
}
```

4.通过close完成重定向

```c
int main(){
    int pid;
    char *args[]={"echo","hello","redirect",0};
    pid=fork();
    if(pid ==0){
        close(1);//close the current filedescripter,is the "1",not the zero!关闭屏幕输出
        open("output.txt",0x201);//0_WRONLY|0_CREATE,but Ican't find the head file把output.txt作为输出目的地
        exec("echo",args);
    }else{
        wait((int *)0);
    }
    exit(0);
}
```



### 管道

### 文件系统



## 第二章 OS Organization and System Calls

### 抽象系统资源

1.将资源抽象为服务

为了让进程之间拥有更好的隔离性(运行时不会相互影响，分时占有cpu资源，在内存中不会访问到其他进程占有的内存)，我们更习惯于禁止应用程序直接访问敏感的硬件，将资源抽象为服务，比如xv6中不允许直接访问磁盘，而是通过调用open,write等系统调用来间接的访问磁盘

2.透明操作

操作系统在进程间透明地切换硬件，保存和恢复寄存器状态，应用程序不会意识到分时共享的存在

一个例子

unix使用exec(系统调用)来构建内存映像，而不是直接与物理内存交互，允许操作系统自行决定进程在内存中的位置，如果内存很紧张，操作系统甚至可以讲一个进程的一些数据暂存在磁盘中



**unix系统调用不是抽象资源的唯一方法，但确实是一个很好的方法**



### 用户态核心态以及系统调用

1.强隔离

应用程序和操作系统间有硬边界，要实现强隔离，操作系统必须保证应用程序不能修改和读取操作系统的数据结构和指令，应用程序不能访问其他进程的内存

2.3种运行模式

用户模式,管理模式，机器模式，第三种先不讲，用的少.

管理模式下,cup允许执行特权指令，比如启动和禁止中断，读取和保存页表地址的寄存器。

如果用户模式下试图执行特权指令，操作系统会先切换到管理模式再执行指令

处于用户模式下的应用软件被称为在用户空间中运行，处于管理模式下的软件可以执行特权指令，被称为在内核空间中运行,**在内核空间(或管理模式)中运行的软件被称为内核**

3.ecall

想要调用内核函数必须进入内核态(或者叫管理模式，或内核空间),为此riscv-v提供了一个指令ecall，通过调用它并提供相应的参数可以进入到内核态并执行你想执行的内核函数(当然，操作系统会对参数进行检查)

比如说你在用户态下想用系统调用fork,其实你在用户态下并不会直接调用fork，而是先通过ecall(3),进入到内核态，把参数"3"给到内核，内核通过这个"3"就知道了用户态想调用fork,他就会执行真正的fork函数，并把相应结果返回到用户态下。

### 内核组织

1.宏内核和微内核

宏内核:

宏内核是指整个操作系统都在内核模式下运行,这样做的好处是整个操作系统的很多功能，比如说虚拟内存，文件管理，可以相互联系而无需在用户态和内核态间相互切换，大大提高了运行效率，所以说一般的桌面操作系统都是宏内核，比如unix,windows,linux等等，当然坏处也有，那就是bug太难修复了,在内核态下我们会直接对硬件进行操作，要求程序必须是可靠的，如果我们把操作系统所有代码全放在内核态下运行难免会有bug。

特权指令只在内核态运行

宏内核的优点就是微内核的缺点，宏内核的缺点就是微内核的优点.

举个例子

shell(本质上也是一个用户程序)调用exec是如何访问到文件系统FS的?

在微内核下，shell调用exec需要访问到文件系统FS,通常的一个工作模式是通过IPC系统发送一个消息给内核,内核查看，知道需要访问文件系统，发送给文件系统，FS发送一条消息，表明这是EXEC系统调用的结果，再发送会Shell,跳入内核跳入内核，跳出内核，系统调用次数过多，因此微内核很难实现高性能

大概这样子

![image-20221025161140272](D:\AppData\Typora\typora-user-images\image-20221025161140272.png)





大多数桌面操作系统都是宏内核系统,二很多嵌入式操作系统如MiniX往往是微内核设计

### 代码:XV6架构篇

1.文件结构

有这些文件夹

kernel 内核

user 用户

mkfs 

makefile 用来对整个项目进行编译的文件，注意做lab的时候要修改一下这个文件 

产生了 kernel/kernel.asm可以用来debug.看到反汇编指令

qemu和内核约定任何程序的起始点是地址80000000

面对qemu我们不能把它想象成一个C程序，而是真正想象成一块电路板



### 进程概述

1.进程

xv6和其他unix操作系统一样，隔离单位是一个进程，每个进程在内存中有独特的物理空间，禁止在内存中访问其他进程。为了加强隔离性，进程抽象给每个进程一个错觉,它们拥有自己的专有机器，进程为程序提供了一个像是私有内存系统和地址空间的东西,其他进程不能读取或者写入

xv6使用页表为每个进程提供自己的地址空间，risc-v页表将虚拟地址转换为物理地址(需要注意的是,在每个进程中，执行程序时会用虚拟地址，但在进程和操作系统的交互时，提供的是物理地址(不然不知道进程到底在哪))

2.地址空间

页表定义了进程的地址空间

指令-全局变量-栈区-堆区

地址空间的最大范围:

RISC-V上的指针有64位宽，硬件在页表中查找虚拟地址时只需要用到低39位，xv6只使用者39位的38位。

在地址空间顶部，分别为trampolineHe 和trapframe保留了一个页面

3.状态片段

每个进程维护了很多状态片段，聚集在proc结构体中,一个进程最重要的内核状态片段就是 页表，内核栈区和运行状态,可以用p->xxx引用proc结构体的元素.

4.线程:

每个进程可以有一个线程或多个线程执行进程的指令，一个线程可以挂起然后恢复,,挂起时，数据存储在进程的栈区里。

线程大部分中状态储存在线程的栈区上，每个进程有两个栈区:一个用户栈区和一个内核栈区,进程进入内核实现系统调用或中断时内核代码在内核栈区上运行,一个进程在内核态时用户栈区仍然保留数据，但处于不活跃的状态

5.再谈ecall指令

一个进程可以执行ecall指令进行系统调用，提升硬件特权级别,并将PC更改为内核定义的入口点。入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈,并通过sret指令返回用户空间，降低硬件的特权级别，并在系统调用完成时恢复执行用户指令。进程的线程可以在内核中阻塞等待I/O，并在I/O完成后恢复到中断的位置。

### 代码:启动XV6和第一个进程

#### 通过gdb进行debug调试看看操作系统启动发生了什么?

让我们的qemu支持gdb调试工具

```shell
make CPUS=1 qemu-gdb

*** Now run 'gdb' in another window.

```

开启gdb

```shell
gdb-multiarch
```

或者

```shell
riscv64-linux-gnu-gdb
```

看你下载的那个调试工具

multiarch提供的一些指令

![image-20221025142801689](D:\AppData\Typora\typora-user-images\image-20221025142801689.png)

#### entry.s

kernel/entry.s

cpu从_entry(kernel/entry.S)开始执行,这时分页处于禁用状态,虚拟地址直接映射到物理地址

![image-20221026135347447](D:\AppData\Typora\typora-user-images\image-20221026135347447.png)

加载程序将xv6内核加载到物理地址为0x80000000的内存中，它将内核放在0x80000000而不是0x0的原因是地址范围0x0:0x80000000包含I/0设备

_entry设置了一个栈区,这样xv6就可以执行c代码,栈的声明在start.c中

![image-20221026135856351](D:\AppData\Typora\typora-user-images\image-20221026135856351.png)

栈是从高地址向低地址增长的，所以我们把栈顶位置设置在stack0+4096的位置，加载到寄存器sp中,有了栈我们就可以执行start函数

#### start函数:

kernel/start.c

```c
void
start()
{
  // set M Previous Privilege mode to Supervisor, for mret.
  unsigned long x = r_mstatus();//start函数在寄存器mstatus中将先前的运行模式改成管理模式，
  x &= ~MSTATUS_MPP_MASK;
  x |= MSTATUS_MPP_S;
  w_mstatus(x);

  // set M Exception Program Counter to main, for mret.
  // requires gcc -mcmodel=medany
  w_mepc((uint64)main);//通过将main函数的地址写进寄存器mepc,将返回地址设为main

  // disable paging for now.
  w_satp(0);//通过向页表寄存器satp写入0在管理模式下禁用虚拟地址转换

  // delegate all interrupts and exceptions to supervisor mode.
  w_medeleg(0xffff);
  w_mideleg(0xffff);
  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

  // configure Physical Memory Protection to give supervisor mode
  // access to all of physical memory.
  w_pmpaddr0(0x3fffffffffffffull);
  w_pmpcfg0(0xf);

  // ask for clock interrupts.
  timerinit();

  // keep each CPU's hartid in its tp register, for cpuid().
  int id = r_mhartid();
  w_tp(id);

  // switch to supervisor mode and jump to main().
  asm volatile("mret");
}
```

start函数在寄存器mstatus中将先前的运行模式改成管理模式，

riscv.h

```c
static inline void 
w_mstatus(uint64 x)
{
  asm volatile("csrw mstatus, %0" : : "r" (x));
}
```



通过将main函数的地址写进寄存器mepc，将返回地址设为main

```c
static inline void 
w_mepc(uint64 x)
{
  asm volatile("csrw mepc, %0" : : "r" (x));
}
```

通过向页表寄存器satp写入0在管理模式下禁用虚拟地址转换

```c
static inline void 
w_satp(uint64 x)
{
  asm volatile("csrw satp, %0" : : "r" (x));
}
```

进入管理模式前,start还要对时钟芯片进行编程以产生计时器中断，做完这些后调用mret这个riscv指令返回到管理模式，这将导致pc的值更改为main函数地址

*引用:一个进程可以执行ecall指令进行系统调用，提升硬件特权级别,并将PC更改为内核定义的入口点。*

```c
  // ask for clock interrupts.
  timerinit();
```

```c
  // switch to supervisor mode and jump to main().
  asm volatile("mret");
```

#### main函数: 

kernel/main.c

```c
#include "types.h"
#include "param.h"
#include "memlayout.h"
#include "riscv.h"
#include "defs.h"

volatile static int started = 0;

// start() jumps here in supervisor mode on all CPUs.
void
main()
{
  if(cpuid() == 0){
    consoleinit();
    printfinit();
    printf("\n");
    printf("xv6 kernel is booting\n");
    printf("\n");
    kinit();         // physical page allocator
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
    procinit();      // process table
    trapinit();      // trap vectors
    trapinithart();  // install kernel trap vector
    plicinit();      // set up interrupt controller
    plicinithart();  // ask PLIC for device interrupts
    binit();         // buffer cache
    iinit();         // inode table
    fileinit();      // file table
    virtio_disk_init(); // emulated hard disk
    
    userinit();      // first user process
    __sync_synchronize();
    started = 1;
  } else {
    while(started == 0)
      ;
    __sync_synchronize();
    printf("hart %d starting\n", cpuid());
    kvminithart();    // turn on paging
    trapinithart();   // install kernel trap vector
    plicinithart();   // ask PLIC for device interrupts
  }

  scheduler();        
}
```

main函数会初始化几个设备和子系统，便通过调用userinit(kernel/proc.c)创建第一个进程，进入用户空间

```c
uchar initcode[] = {
  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

// Set up first user process.
void
userinit(void)
{
  struct proc *p;

  p = allocproc();
  initproc = p;
  
  // allocate one user page and copy init's instructions
  // and data into it.
  uvminit(p->pagetable, initcode, sizeof(initcode));
  p->sz = PGSIZE;

  // prepare for the very first "return" from kernel to user.
  p->trapframe->epc = 0;      // user program counter
  p->trapframe->sp = PGSIZE;  // user stack pointer

  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");

  p->state = RUNNABLE;

  release(&p->lock);
}
```

第一个进程执行一个用RISCV程序集写的小型程序initcode.S(user/initcode.S)，(这3条或4条指令，返回内核空间)

```assembly
# Initial process that execs /init.
# This code runs in user space.

#include "syscall.h"

# exec(init, argv)
.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec//调用exec进入内核
        ecall	//ecall+SYS_exec

# for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit

# char init[] = "/init\0";
init:
  .string "/init\0"

# char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
```



它通过调用exec系统调用重新进入内核，用一个新的进程替代当前进程的内存和寄存器，调用syscall函数

kernel/syscall

```c
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

这里的num是7，查看syscall.h发现7是系统调用sys_exec

然后我们就到了sys_exec,他在kernel/sysfile文件里

```c
sys_exec(void)
{
  char path[MAXPATH], *argv[MAXARG];
  int i;
  uint64 uargv, uarg;

  if(argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0){
    return -1;
  }
  memset(argv, 0, sizeof(argv));
  for(i=0;; i++){
    if(i >= NELEM(argv)){
      goto bad;
    }
    if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
      goto bad;
    }
    if(uarg == 0){
      argv[i] = 0;
      break;
    }
    argv[i] = kalloc();
    if(argv[i] == 0)
      goto bad;
    if(fetchstr(uarg, argv[i], PGSIZE) < 0)
      goto bad;
  }
```

这个函数首先从用户空间获取参数,获取路径名

```c
if(argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0)
```

注意这一行

```c
  memset(argv, 0, sizeof(argv));
```

memset为参数分配空间，将所有参数从用户空间复制到内核空间，后面我们会见到更多的细节，基本上是一些代码把参数从用户空间移动到内核空间



一旦完成exec，他就返回／init(user/init.c)进程中的用户空间

```c
// init: The initial user-level program

#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/spinlock.h"
#include "kernel/sleeplock.h"
#include "kernel/fs.h"
#include "kernel/file.h"
#include "user/user.h"
#include "kernel/fcntl.h"

char *argv[] = { "sh", 0 };

int
main(void)
{
  int pid, wpid;

  if(open("console", O_RDWR) < 0){
    mknod("console", CONSOLE, 0);
    open("console", O_RDWR);
  }
  dup(0);  // stdout
  dup(0);  // stderr

  for(;;){
    printf("init: starting sh\n");
    pid = fork();
    if(pid < 0){
      printf("init: fork failed\n");
      exit(1);
    }
    if(pid == 0){
      exec("sh", argv);
      printf("init: exec sh failed\n");
      exit(1);
    }

    for(;;){
      // this call to wait() returns if the shell exits,
      // or if a parentless process exits.
      wpid = wait((int *) 0);
      if(wpid == pid){
        // the shell exited; restart it.
        break;
      } else if(wpid < 0){
        printf("init: wait returned an error\n");
        exit(1);
      } else {
        // it was a parentless process; do nothing.
      }
    }
  }
}

```

init基本上就是为用户空间设置一些东西，打开console,console的文件描述符，复制几次，调用fork

然后创建一个进程，然后exec shell

对对对，xv6就这样开始运行啦

![image-20221026155311000](D:\AppData\Typora\typora-user-images\image-20221026155311000.png)

### 思维导图

## 第三章 页表

### GDT,地址分段，地址分页，线性地址，虚拟地址，物理地址

### 分页硬件

分页硬件通过使用虚拟地址39位中的前27位索引页表，以找到该虚拟地址对应的一个PTE，然后生成一个56位的物理地址，其前44位来自PTE中的PPN，其后12位来自原始虚拟地址。

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p1.png)

实际的转换分三个步骤进行。页表以三级的树型结构存储在物理内存中。该树的根是一个4096字节的页表页，其中包含512个PTE，每个PTE中包含该树下一级页表页的物理地址。这些页中的每一个PTE都包含该树最后一级的512个PTE（也就是说每个PTE占8个字节，正如图3.2最下面所描绘的）。分页硬件使用27位中的前9位在根页表页面中选择PTE，中间9位在树的下一级页表页面中选择PTE，最后9位选择最终的PTE。

![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p2.png)



如果转换地址所需的三个PTE中的任何一个不存在，页式硬件就会引发页面故障异常（page-fault exception），并让内核来处理该异常（参见第4章）。

与图 3.1 的单级设计相比，图 3.2 的三级结构使用了一种更节省内存的方式来记录  PTE。在大范围的虚拟地址没有被映射的常见情况下，三级结构可以忽略整个页面目录。举个例子，如果一个应用程序只使用了一个页面，那么顶级页面目录将只使用条目0，条目 1 到 511 都将被忽略，因此内核不必为这511个条目所对应的中间页面目录分配页面，也就更不必为这 511 个中间页目录分配底层页目录的页。 所以，在这个例子中，三级设计仅使用了三个页面。

每个PTE包含标志位，这些标志位告诉分页硬件允许如何使用关联的虚拟地址。`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用

为了告诉硬件使用页表，内核必须将根页表页的物理地址写入到`satp`寄存器中（`satp`的作用是存放根页表页在物理内存中的地址）。每个CPU都有自己的`satp`，一个CPU将使用自己的`satp`指向的页表转换后续指令生成的所有地址。每个CPU都有自己的`satp`，因此不同的CPU就可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。



### 内核地址空间

### 代码:创建一个地址空间

### 物理内存分配

### 代码:物理内存分配

### 进程地址空间

### 代码:sbrk

### 代码:exec

进程在内存中不能访问其他其他进程的内存

mmu将虚拟地址转化为物理地址

寄存器satp保存着页表的位置，cpu告诉内存管理单元mmu到哪里寻找把虚拟地址转换为物理地址的映射，mmu不保存映射只做转换，

每个进程拥有一个自己特有的页表，当进程切换时，它也会切换satp寄存器的内容。

每个进程的satp寄存器的值是由内核保存的，写入或读取是一个特权指令，只有内核模式的代码能够修改它。

画出来的像是每个虚拟地址都有都在映射中有一个条目，如果这么做的话会有2^64大，仅仅包含这张表就会使用掉所有的内存，这肯定是不现实的。

其实不是对每个虚拟地址有一个映射，而是对每个页面有一个映射，在RSCV中，一个页是4KB，也就是4096字节。这是习惯决定的，几乎所有的处理器页面大小使用4KB，或者支持4KB



虚拟地址分为两部分:索引和偏移量，MMU做转换时使用索引在映射中找到页表编号，页表编号指向4096字节中的一些物理页，再通过偏移量12知道那个页的12个条目被使用

虚拟地址的最高25位没有使用，限制了虚拟地址空间，虚拟空间地址只有64-25=39位大概512G，索引还剩下了39位，27位作为索引，12位作为偏移地址，必须是12，因为2^12=4096，这样才能在页表中找到条目

物理页面的4096字节是连续的在物理地址中，因为映射是以4096字节为粒度的

物理内存56位，这是设计师决定的，所以说物理内存比虚拟内存大(条目44位physical+12位偏移量)

真正的RISCV页表结构:多级结构

顶部9位作为顶层页表目录的索引，4096字节和页面大小一样

