## 动态规划

学习了动态规划，受益良多,动态规划的思想就是从一些初值进行递推最终得到最终的答案。

主要分为两类:
1.初值是从中间开始拓展的

典型:链式矩阵问题,给定一系列矩阵，每个矩阵的维数分别是给定的一个数组p的元素p[i]p[i+1],已知i,j维和j,k维的两个矩阵相乘需要的运算规模为i\*j*k,求这一系列矩阵相乘需要的最小运算规模

首先明确一个理念，最终的答案一定，但是通过结合律我们可以大大减小运算次数，我们这样考虑:给定从i到j的这几个矩阵,若能找到k满足i到k的运算规模最小且从k+1到j的运算规模也最小，则从i到j的这种情况下运算规模最小,证明:假设反证(看书)

所以我们以此结论来将子问题一波波扩大得到最终的答案.

由于矩阵的结合是从中间开始的，所以我们不能想当然的考虑从左边推到右边，而是用i表示左边界，j表示右边界

dp边界条件:如果i==j，则dp\[i][j]=0，如果j-i==1，则dp\[i][j]=p\[i]*p[j]\*p[j+1]

递归条件:找一个k在i和j之间遍历地插入，直到找到那个最小的dp\[i][j]

2.初值是从一端往另一边拓展的

典型:投资问题,背包问题

这是一个最优化问题

要求利益(价值)最大，有一定限制(本金，载重)

对这种问题，我们常常弄一个二维数组保存数据,其中第一维表示前k间物品，第二维面相限制条件:最多载重j

所以递推方程:

背包:dp\[i][j]=max(dp\[i-1][j],dp\[i][j-w[i]]+v[i])

投资问题:

dp\[i][j]=max(dp\[i-1][j-k]+f\[i][k],dp\[i][j])//这里用了三重循环,k是在i和j之间插入遍历的数。

另外，还可以分为