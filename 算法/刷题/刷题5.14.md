### 5.13

每日一题(难度较低)

![image-20220514213251733](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514213251733.png)

双指针

```java
import static java.lang.Math.abs;
class Solution {
    public boolean oneEditAway(String first, String second) {
        int n = first.length();
        int m = second.length();
        int count = 0;
        int i = 0;
        //修改的情况
        if (n == m) {
            for (i = 0; i < n; i++) {
                if (first.charAt(i) != second.charAt(i)) {
                    count++;
                }
            }
            if (count >= 2) {
                return false;
            }else
                return true;
        }
        //删除或添加的情况
            if (abs(n - m) == 1) {
                int j = 0;

                while (i < n && j < m && count < 2) {
                    if (first.charAt(i) != second.charAt(j)) {
                        count++;
                        if (n > m) {
                            i++;
                        } else {
                            j++;
                        }
                    }else{
                    i++;
                    j++;
                    }
                }
                if (count >= 2) {
                    return false;
                } else {
                    return true;
                }
            }
        //其他情况下返回false
        return false;
    }
}
```

也可考虑使用动态规划

```java
class Solution {
    public boolean oneEditAway(String first, String second) {
        int m = first.length(), n = second.length();
        if (Math.abs(m - n) > 1) {
            return false;
        }

        if (m != n) {
            // dp[i][j]：表示first[0..i-1]和second[0..j-1]的最长公共子列的长度
            int[][] dp = new int[m + 1][n + 1];
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    if (first.charAt(i - 1) == second.charAt(j - 1)) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][	j], dp[i][j - 1]);
                    }
                }
            }
            return dp[m][n] == Math.min(m, n);
        } else {
            return canOneEdit(first, second);
        }
    }

    private boolean canOneEdit(String s1, String s2) {
        int count = 0;
        for (int i = 0, len = s1.length(); i < len; i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                ++count;
            }
            if (count > 1) {
                return false;
            }
        }
        return true;
    }
}

```

![image-20220515110142710](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515110142710.png)

### 5.14

11.盛最多水的容器(难度较低)

![image-20220514213958749](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514213958749.png)

![image-20220514214015671](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220514214015671.png)

双指针

核心思想是贪心,尽可能让面积更大，面积的计算公式是底乘高，即

p*math.min(height[l],height[j]),拥有两个变量，我们让p线性减小的情况下对hmin贪心，即比较height[l]和height[r]，让更小的进行移动。

```java
class Solution {
    public int maxArea(int[] height) {
        int ans=0;
        int l=0;
        int r=height.length-1;
        while(l<=r){
            ans=Math.max(Math.min(height[l],height[r])*(r-l),ans);
            if(height[l]<=height[r]){
                l++;
            }else{
                r--;
            }
        }
        return ans;
    }
}
```



前缀和的简单应用

原数列

前缀和数列s[i]=a[1]+a[2]+...+a[i]

运用前缀和数列求一个区间的和时间复杂度和减小到o(1),

比如求a[l]+a[l+1]+...+a[r-1]+a[r],直接=s[r]-s[l-1]事件复杂度从o(n)减小到o(1)

代码

```java
public static int search(int []nums,int l,int r){
    int[] num2=new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j <= i; j++) {
            num2[i]+=nums[j];
        }
    }
    int cnt=0;
    cnt=num2[r-1]-num2[l-2];
    return cnt;
}
```







### 5.15

每日一题

最大三角形面积（几何算法）

s=1/2\*dmid*(hmax-hmin)

考虑使用贪心算法

保证hmax-hmin最大的情况下保证dmid最大

不考虑排序，不考虑递归，可以遍历，是一个二维数组，

算了放弃了。

算了，考虑dP算法，用dp\[i][0]表示不取这个点时的面积，dp\[i][1]取这个点时候的面积，和之前的不太一样，这里取点最多取三个，而且最前面的2个点无法构成三角形，且递推无法进行下去。



题解:

1.数学+枚举

三角形面积公式

![image-20220515110630388](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515110630388.png)

由于三个点是等价的(可互换),遍历时可以优化j从i+1开始，k从j+1开始

```java
class Solution {
    public double largestTriangleArea(int[][] points) {
        int n = points.length;
        double ret = 0.0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    ret = Math.max(ret, triangleArea(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]));
                }
            }
        }
        return ret;
    }

    public double triangleArea(int x1, int y1, int x2, int y2, int x3, int y3) {
        return 0.5 * Math.abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);
    }
}


```

2.凸包解法参考587.安装栅栏

Andrew扫描法

将凸包分为上凸壳和下凸壳

![image-20220515120053893](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515120053893.png)

1.将所有点按2个指标进行排序，先按x坐标升序排列，再按y坐标升序排列

2.用栈维护所有凸包上的点，或者说是凸包上的边，凸包起点元素会在栈中出现两次。

3.分别从前往后和从后往前处理排序好的所有点，来分别画出凸包的两半部分，根据画的是第一部分还是第二部分，维护站内元的处理稍稍不同。

a.画的是第一部分

- 栈内元素少于2个，说明第一条边未画出，直接将元素添加到栈中
- 元素不少于2个会考虑是否删掉栈顶的边，根据时针方向来决定是否删除
- ![image-20220515120545943](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220515120545943.png)

模板：

```java
class Solution {
    int[] subtraction(int[] a, int[] b) { // 向量相减
        return new int[]{a[0] - b[0], a[1] - b[1]};
    }
    double cross(int[] a, int[] b) { // 叉乘
        return a[0] * b[1] - a[1] * b[0];
    }
    double getArea(int[] a, int[] b, int[] c) { // 向量 ab 转为 向量 ac 过程中扫过的面积
        return cross(subtraction(b, a), subtraction(c, a));
    }
    public int[][] outerTrees(int[][] trees) {
        //排序
        Arrays.sort(trees, (a, b)->{
            return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];
        });
        int n = trees.length, tp = 0;
        int[] stk = new int[n + 10];
        boolean[] vis = new boolean[n + 10];
        stk[++tp] = 0; // 不标记起点
        //维护栈
        for (int i = 1; i < n; i++) {
            int[] c = trees[i];
            //tp大于2
            while (tp >= 2) {
                int[] a = trees[stk[tp - 1]], b = trees[stk[tp]];
                if (getArea(a, b, c) > 0) vis[stk[tp--]] = false;
                else break;
            }
            //tp小于2直接加
            stk[++tp] = i;
            vis[i] = true;
        }
        int size = tp;
        for (int i = n - 1; i >= 0; i--) {
            if (vis[i]) continue;
            int[] c = trees[i];
            while (tp > size) {
                int[] a = trees[stk[tp - 1]], b = trees[stk[tp]];
                if (getArea(a, b, c) > 0) tp--;
                // vis[stk[tp--]] = false; // 非必须
                else break;
            }
            stk[++tp] = i;
            // vis[i] = true; // 非必须
        }
        int[][] ans = new int[tp - 1][2];
        for (int i = 1; i < tp; i++) ans[i - 1] = trees[stk[i]];
        return ans;
    }
}
```



### 5.16

每日一题

![image-20220516115426741](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516115426741.png)

最近才学了二叉树的前序，中序，后序遍历，那就用中序遍历的方法找到后继节点。

习惯这种数组形式的node，其实和普通的node是一样的

第一次提交

```java
import java.util.Stack;

class Solution {
    public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur=root;
        TreeNode pre=null;
        if(root!=null){
            Stack<TreeNode> stack=new Stack<>();
            stack.push(cur);
            while(cur.left!=null){
                cur=cur.left;
                stack.push(cur);
            }
            cur=null;
            while(!stack.isEmpty()){
                pre=cur;
                cur=stack.pop();
                if(pre==p){
                    return cur;
                }
                if(cur.right!=null){
                    stack.push(cur.right);
                }
            }
            return null;
        }
        return null;
    }
```



![image-20220516122626262](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516122626262.png)

这里有点问题啊,两个while循环被割裂开了，我要做的是把每一棵树的左节点都放入栈，我这里只把最大的树的左节点放入了栈，所以一定出问题



第二次提交

很聪明的让cur.left的加入和cur.right的加入在一个while循环中进行

很聪明的加入了count元素，让pre在第一次等于Null，后面均等于cur，然鹅还是出错，我服了。

```java
import java.util.Stack;

class Solution {
    public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur=root;
        TreeNode pre=null;
        int count=0;
        if(root!=null){
            Stack<TreeNode> stack=new Stack<>();
            stack.push(cur);
            while(!stack.isEmpty()) {
                if (cur.left != null) {
                    cur = cur.left;
                    stack.push(cur);
                } else {
                    if(count==0){
                        pre=null;
                        count++;
                    }else {
                        pre=cur;
                    }
                        cur = stack.pop();
                        if (pre == p) {
                            return cur;
                        }
                        if (cur.right != null) {
                            stack.push(cur.right);
                        }

                }

            }
            return null;
        }
        return null;
    }
}
```

![image-20220516130046045](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220516130046045.png)



正确答案

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode prev = null, curr = root;
        while (!stack.isEmpty() || curr != null) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            if (prev == p) {
                return curr;
            }
            prev = curr;
            curr = curr.right;
        }
        return null;
    }
}
```

当然，由于题目上给了是一个BST，所以可以直接使用BST的性质

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        //递归终止条件
        if (root == null) return null;
        //root值小于等于p直接去右边root找
        if (root.val <= p.val) return inorderSuccessor(root.right, p);
        TreeNode ans = inorderSuccessor(root.left, p);
        return ans == null ? root : ans;
    }
}
```

### 5.17

状态dp问题:

打家劫舍1

![image-20220518001321249](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001321249.png)

打家劫舍2

![image-20220518001350161](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001350161.png)

打家劫舍3(树形dp)

![image-20220518001433874](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001433874.png)



贪心算法:

跳跃游戏

![image-20220518001512559](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001512559.png)

零钱兑换

![image-20220518001541649](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001541649.png)



前缀和问题:

相同元素的间隔之和

![image-20220518001613498](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220518001613498.png)

### 5.18

![image-20220519221123673](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220519221123673.png)

简单做法:

使用贪心策略知这个数中位数时最小

```java
public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int n=nums.length;
    int mid=(n-1)/2;
    int ans=0;
    for (int i = 0; i < n; i++) {
        ans+=Math.abs(nums[i]-nums[mid]);
    }
    return ans;
}
```

优化:

快速选择使事件复杂度进一步减小,用于解决topk问题

### 5.19

215 数组中第k大的元素
![image-20220519221404241](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220519221404241.png)

法一:维护一个堆

因为要求第k大的元素，我们可以维护一个容量大小为k的堆,堆顶元素就是第k大的元素

法二:快速选择

对于动态数据流只能使用堆排序

核心思想是随机选择一个轴值，对于小于该轴值的数放在轴值左边，大于该轴值的数放在轴值右边,然后根据k和轴值的关系

平均时间复杂度on 

### 5.20 

每日一题

自己做:暴力

```java
class Solution {
        public int[] findRightInterval(int[][] intervals) {
        int n = intervals.length;
        int[] ans = new int[n];
        int temp = -1;
        int minInterval = Integer.MAX_VALUE;
        if (n == 1) {
            ans[0] = -1;
            return ans;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (intervals[j][0] - intervals[i][1] < minInterval) {
                    minInterval = intervals[j][0];
                    temp = j;
                }
            }
            ans[i] = temp;
            minInterval=Integer.MAX_VALUE;
        }
        return ans;
    }
}
```

### 5.21

每日一题(简单)



98.验证二叉搜索树

中序遍历

1.递归实现

出问题了

```java
    public boolean isValidBST(TreeNode root) {
    if(root==null){
        return true;
    }
    if(root.left!=null){
        isValidBST(root.left);
    }
    if(this.val>this.left.val&&this.val<this.right.val){
        return true;
    }
    if(root.right!=null){
        isValidBST(root.right);
    }
    }
```

2.栈实现

气死我了卡数值范围

把pre改成Long.MIN_VALUE即可

```java
class Solution {
       public boolean isValidBST(TreeNode root) {
        if(root!=null) {
            Stack<TreeNode> stack = new Stack<>();
            long pre=Long.MIN_VALUE;
            while(!stack.isEmpty() || root!=null){
                if(root!=null){
                    stack.add(root);
                    root=root.left;
                }else {
                    root=stack.pop();
                    if(root.val<=pre){
                        return false;
                    }else {
                        pre=root.val;
                    }
                    root=root.right;
                }
            }
        }
        return true;
    }
}

```



3.递归套路



292场周赛第二题

统计值等于子树平均值的节点数

![image-20220521172719000](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220521172719000.png)

思路:从子树想父亲拓展，由子树的平均值算出父树的平均值，使用递归处理，比较难以解决的是子树的平均值如何转化到父亲的平均值:

使用一个leftcnt记录左子树的节点数一个rightcnt右子树的结点数目，

由于cnt是每个树自身特有的，所以定义在dfs中

总结:还是代码能力不够，不能很好地在递归过程中动态处理数据.

理解递归过程

写一段代码

```java
class Solution {
    int cnt=1;
    int answer=0;

    public int dfs(TreeNode head){
        int ans=head.val;
        if(head.left!=null){
            ans+=dfs(head.left)*cnt;
        }
        if(head.right!=null){
            ans+=dfs(head.right)*cnt;
        }
        if(ans/cnt==head.val){
            answer+=1;
        }
        System.out.println(head.val+":" +ans+":"+cnt);
        cnt+=1;
        return ans/cnt;
    }
    public int averageOfSubtree(TreeNode root) {
        int x = dfs(root);
        return answer;

    }

    public static void main(String[] args) {
        TreeNode treeNode1 = new TreeNode(4);
        TreeNode treeNode2 = new TreeNode(8);
        TreeNode treeNode3 = new TreeNode(0);
        TreeNode treeNode4 = new TreeNode(1);
        TreeNode treeNode5 = new TreeNode(5);
        TreeNode treeNode6 = new TreeNode(6);
        treeNode1.left=treeNode2;
        treeNode2.left=treeNode3;
        treeNode2.right=treeNode4;
        treeNode1.right=treeNode5;
        treeNode5.right=treeNode6;
        Solution solution = new Solution();
        solution.averageOfSubtree(treeNode1);

    }
}
  class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
 }
```

贪心问题:

剑指offer103最少的硬币数

![image-20220521222536218](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220521222536218.png)

我开始做的贪心是能取最大面额就取最大面额，否则取较小的那一个，但是有一个漏洞，就是当硬币面额不是倍数关系时有时候明明能兑换但我误判了不能换.

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int ans=0;
        Arrays.sort(coins);
        int i=coins.length-1;
        while(i>=0){
            if(coins[i]<=amount&&amount>=0){
                ans++;
                amount-=coins[i];
            }else{
                i--;
            }
        }
        if(amount>0){
            return -1;
        }
        return ans;
    }
}
```

错误案例

### 5.22

周赛

1.简单

![image-20220522182844393](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182844393.png)

```java
class Solution {
        public int percentageLetter(String s, char letter) {
        int sum=0;
        char[] chars = s.toCharArray();
        for(char chr:chars){
            if(chr==letter){
                sum+=100;
            }
        }
        return  sum/s.length();
    }
}

```

2.![image-20220522182809356](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182809356.png)

思路:堆

```java
class Solution {
        public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int sum=0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 0; i < capacity.length; i++) {
            pq.add(capacity[i]-rocks[i]);
        }
        while(!pq.isEmpty()&&pq.peek()<=additionalRocks&&additionalRocks>=0){
            additionalRocks-=pq.poll();
            sum++;
        }
        return sum;
    }
}
```

3.

![image-20220522120723328](C:/Users/34488/AppData/Roaming/Typora/typora-user-images/image-20220522120723328.png)

![image-20220522182545216](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182545216.png)

思路:排序+双指针

注意不能用斜率，斜率全部转化为相等.

```java
class Solution {
        public int minimumLines(int[][] stockPrices) {
        if(stockPrices.length==1){
            return 0;
        }
        int ans=0;
        Arrays.sort(stockPrices,new mycomparator());
        int l=0;
        int r=1;
        while(r<stockPrices.length){
            int curx1=stockPrices[l+1][0]-stockPrices[l][0];
            int cury1=stockPrices[l+1][1]-stockPrices[l][1];
            int curx2=stockPrices[r][0]-stockPrices[l][0];
            int cury2=stockPrices[r][1]-stockPrices[l][1];
            if(curx1*cury2==curx2*cury1){
                r++;
            }else{
                ans++;
                l=r-1;
                r=l+1;
            }
        }
        ans++;
        return ans;
    }
}
class mycomparator implements Comparator<int[]> {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0] - o2[0];
    }
}
```

大佬

```java
class Solution {

	public int minimumLines(int[][] stockPrices) {
		Arrays.sort(stockPrices, (o, p) -> o[0] - p[0]);
		int count = 0;
		for (int i = 1; i < stockPrices.length; i++) {
			count += i > 1 && (long) (stockPrices[i][0] - stockPrices[i - 1][0]) * (stockPrices[i - 1][1]
					- stockPrices[i - 2][1]) == (long) (stockPrices[i - 1][0] - stockPrices[i - 2][0])
							* (stockPrices[i][1] - stockPrices[i - 1][1]) ? 0 : 1;
		}
		return count;
	}
}
```



4.

![image-20220522182725855](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220522182725855.png)

### 5.23

每日一题

![image-20220523213858039](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220523213858039.png)

这道题是做过的吧..

bfs+并查集

错误:我想不明白为什么会栈溢出,该return的时候我return了呀,就是[i,j]越界或者now==0的时候return,为什么递归跑不完呢

```java
class Solution {
    int ans=0;
    public int cutOffTree(List<List<Integer>> forest) {
        int m=forest.size();
        int n=forest.get(0).size();
        process(forest,0,0,m,n);
        return ans;
    }
    public void process(List<List<Integer>> forest,int i,int j,int m,int n){
        if(i<0||i>=m||j<0||j>=n){
            return;
        }
        int now=forest.get(i).get(j);
        if(now==0){
            return;
        }
        if(now>1){
            now=1;
            ans++;
        }
        process(forest,i-1,j,m,n);
        process(forest,i+1,j,m,n);
        process(forest,i,j-1,m,n);
        process(forest,i,j+1,m,n);

    }
}
```

正解:

bfs

```java
class Solution {
    int N = 50;
    int[][] g = new int[N][N];
    int n, m;
    public int cutOffTree(List<List<Integer>> forest) {
        n = forest.size(); m = forest.get(0).size();
        List<int[]> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = forest.get(i).get(j);
                if (g[i][j] > 1) list.add(new int[]{g[i][j], i, j});
            }
        }
        Collections.sort(list, (a,b)->a[0]-b[0]);
        int x = 0, y = 0, ans = 0;
        for (int[] ne : list) {
            int nx = ne[1], ny = ne[2];
            int d = bfs(x, y, nx, ny);
            if (d == -1) return -1;
            ans += d;
            x = nx; y = ny;
        }
        return ans;
    }
    int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int bfs(int X, int Y, int P, int Q) {
        if (X == P && Y == Q) return 0;
        boolean[][] vis = new boolean[n][m];
        Deque<int[]> d = new ArrayDeque<>();
        d.addLast(new int[]{X, Y});
        vis[X][Y] = true;
        int ans = 0;
        while (!d.isEmpty()) {
            int size = d.size();
            while (size-- > 0) {
                int[] info = d.pollFirst();
                int x = info[0], y = info[1];
                for (int[] di : dirs) {
                    int nx = x + di[0], ny = y + di[1];
                    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                    if (g[nx][ny] == 0 || vis[nx][ny]) continue;
                    if (nx == P && ny == Q) return ans + 1;
                    d.addLast(new int[]{nx, ny});
                    vis[nx][ny] = true;
                }
            }
            ans++;
        }
        return -1;
    }
}


作者：AC_OIer
链接：https://leetcode.cn/problems/cut-off-trees-for-golf-event/solution/by-ac_oier-ksth/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



lc1.两数之和



lc2.两数相加

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int x=0;
    int y=0;
    int z=0;
    ListNode ans;
    if(l1==null||l2==null){
        return l1==null?l2:l1;
    }
    x=l1.val+l2.val>=10?1:0;
    y=l1.val+l2.val-10*x;
    ans=new ListNode(y);
    ListNode cur1=ans;
    //l1,l2的公共部分
    while(l1.next!=null&&l2.next!=null){
        l1=l1.next;
        l2=l2.next;
        z=x;
        x=l1.val+l2.val+z>=10?1:0;
        y=l1.val+l2.val-10*x+z;
        cur1.next=new ListNode(y);
        cur1=cur1.next;
    }
    //l1,l2的公共部分之外.
    ListNode cur=l1.next==null?l2:l1;
    while(cur.next!=null){
        cur=cur.next;
        z=x;
        x=cur.val+z>=10?1:0;
        y=cur.val+z-10*x;
        cur1.next=new ListNode(y);
        cur1=cur1.next;
    }
    if(x==1){
        cur1.next=new ListNode(1);
    }
    return ans;
    }
}
```



lc3.无重复字符的最长子串

滑动窗口

```java
    public int lengthOfLongestSubstring(String s) {
        char[] chars = s.toCharArray();
        HashSet<Character> set = new HashSet<Character>();
        int l=0;
        int r=0;
        int ans=0;
        while (r<chars.length&&l<=r){
            if(!set.contains(chars[r])){
                set.add(chars[r]);
                r++;
            }else{
                set.remove(chars[l]);
                l++;
            }
            ans=Math.max(ans,r-l);
        }
        return ans;
    }
```



lc5.最长回文子串



往届周赛题



253场周赛

难度3456

5838.检查字符是否为数组前缀

模拟+动态判断

```java
    public boolean isPrefixString(String s, String[] words) {
        StringBuilder str= new StringBuilder();
        for(String word:words){
            str.append(word);
            if(str.toString().equals(s)){
                return true;
            }
        }
        return false;
    }

```



5839.移除石子使总数最小

使用一个堆维护得到最大值.

```java
class Solution {
    public int minStoneSum(int[] piles, int k) {
        int ans=0;
        PriorityQueue<Integer> heap = new PriorityQueue<>(new myComparator());
        for(int i:piles){
            heap.add(i);
        }
        while(k>0&&!heap.isEmpty()){
            int now=(heap.poll()+1)/2;
            heap.add(now);
            k--;
        }
        while(!heap.isEmpty()){
            ans+=heap.poll();
        }
        return ans;
    }
}
class myComparator implements  Comparator<Integer>{
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2-o1;
    }
}
```



5840.使字符串平衡的最小交换次数

逻辑出错,我的思路是维护一个栈，如果要加入的元素是]而栈顶元素是[,则把栈顶弹出,但是这是错误的，

比如]]\][[[,

执行下述操作可以使字符串变成平衡字符串：
- 交换下标 0 和下标 4 对应的括号，s = "[]][][" 。
- 交换下标 1 和下标 5 对应的括号，s = "[[][]]" 。
  最终字符串变成 "[[][]]" 。

正确答案:

```java
class Solution {
    public int minSwaps(String s) {
        int count=0，res=0;
        for (char c : s.toCharArray()) {
            if(c=='['){
                count++;
            }else{
                count--;
                if(count<0){
                    //得到]，res++
                    count=0;
                    res++;
                }
            }
        }
        return (res+1)/2;
    }

}
```

讨论中提到了可以使用前缀和的方式,有机会了解一下.



5841.找出每个位置为止最长的有效障碍赛跑路线





280场周赛

难度3456

### 5.24

每日一题

![image-20220524130321204](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220524130321204.png)

1.使用morris遍历将空间复杂度降低

```java
    class Solution {
        public boolean isUnivalTree(TreeNode head){
        if(head==null){
            return true;
        }
        TreeNode cur=head;
        TreeNode mostRight;
        while(cur!=null){
            mostRight=cur.left;
            //cur的左树不为空时执行
            if(mostRight!=null){
                //找到mostRight
                while(mostRight.right!=null&&mostRight.right!=cur){
                    mostRight=mostRight.right;
                }
                //第一次来到cur时
                if(mostRight.right==null){
                    mostRight.right=cur;
                    cur=cur.left;
                    continue;
                }else{//第二次来到cur
                    mostRight.right=null;
                }
            }
            if(cur.val!=head.val){
                return false;
            }
            cur=cur.right;
        }
        return true;
    }
}
```



2.正常递归动态判断

```java
class Solution {
    public boolean isUnivalTree(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (root.left != null) {
            if (root.val != root.left.val || !isUnivalTree(root.left)) {
                return false;
            }
        }
        if (root.right != null) {
            if (root.val != root.right.val || !isUnivalTree(root.right)) {
                return false;
            }
        }
        return true;
    }
}
```

### 5.25

1.每日一题

![image-20220526215749668](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220526215749668.png)

```java
        public int findSubstringInWraproundString(String p) {
            int pre=1;
            int ans=0;
            String str="";
        HashSet<String> set = new HashSet<>();
        for (int i = 0; i < p.length(); i++) {
            if(i>=1&&(p.charAt(i)-p.charAt(i-1)==1||(p.charAt(i)=='a'&&p.charAt(i-1)=='z'))){
                pre++;
                str+=p.charAt(i);
            }else {
                pre=1;
                str="";
                str+=p.charAt(i);
            }
            if(!set.contains(str)) {
                ans += pre;
                set.add(str);
                String str2="";
                str2+=p.charAt(i);
                set.add(str2);
            }
        }
        return ans;
    }
```

草有点小bug

```java
class Solution {
    public int findSubstringInWraproundString(String p) {
        int[] dp = new int[26];
        int k = 0;
        for (int i = 0; i < p.length(); ++i) {
            if (i > 0 && (p.charAt(i) - p.charAt(i - 1) + 26) % 26 == 1) { // 字符之差为 1 或 -25
                ++k;
            } else {
                k = 1;
            }
            dp[p.charAt(i) - 'a'] = Math.max(dp[p.charAt(i) - 'a'], k);
        }
        return Arrays.stream(dp).sum();
    }
}
```





前缀和+动态规划

初识前缀和，后面填坑:

1.



2.找出一个二维数组中在同一行中最大，同一列中最小的坐标

模拟即可

```java
public class test {
    public static void main(String[] args) {
        int[][] arrs=new int[5][5];
        arrs[0]= new int[]{1, 2, 3, 4, 5};
        arrs[1]=new int[]{ 1  ,2 ,8 ,8 ,6 };
        arrs[2]=new int[]{ 8  ,1 ,5 ,2 ,6 };
        arrs[3]=new int[]{ 14 ,26,32,8 ,21 };
        arrs[4]=new int[]{ 155,65,6 ,25,8 };

        int[] biggest = new int[5];
        int big;
        int small;
        int[] smallest=new int [5];
        for (int i=0; i < 5; i++) {
            big = 0;
            for (int j = 0; j < 5; j++) {
                if (arrs[i][j] > big) {
                    big = arrs[i][j];
                    biggest[i] = j;
                }
            }
        }
        for (int i=0; i < 5; i++) {
            small = Integer.MAX_VALUE;
            for (int j = 0; j < 5; j++) {
                if (arrs[j][i] <small ) {
                    small=arrs[j][i];
                    smallest[i] = j;
                }
            }
        }
        for (int i = 0; i < 5; i++) {
            if (smallest[biggest[i]] == i) {
                System.out.println(i+","+biggest[i]);
            }
        }
    }
}
```

### 5.26

每日一题

699掉落的方块

![image-20220526143436482](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220526143436482.png)

初识线段树,后面填坑

对于值域爆炸，查询有限的问题采用的思路:

1.模拟

2.有序集合(红黑树)

3.线段树(动态开点或离散化+线段树),对于非强制在线的情况可以直接使用离散化，对于强制在线的情况只能使用动态开点.

例如:729.我的日程安排1

![image-20220526144212977](https://raw.githubusercontent.com/lozijy/github_-/main/image-20220526144212977.png)

1.模拟:自然思维

使用一个列表，遍历每一个list中的每一个数组检查book是否会与list中的时间冲突，若冲突则返回false,否则将其添加到list中并返回true;

```java
class MyCalendar {
    List<int[]> list = new ArrayList<>();
    public boolean book(int start, int end) {
        end--;
        for (int[] info : list) {
            int l = info[0], r = info[1];
            if (start > r || end < l) continue;
            return false;
        }
        list.add(new int[]{start, end});
        return true;
    }
}
```

2.红黑树

```java
class MyCalendar {
    TreeMap<Integer, Integer> tm = new TreeMap<>();    
    public boolean book(int start, int end) {
        Integer prev = tm.floorKey(start), next = tm.ceilingKey(start);
        if ((prev == null || tm.get(prev) <= start) && (next == null || end <= next)) {
            tm.put(start, end);
            return true;
        }
        return false;
    }
}
```

3.线段树(动态开点)

这道题属于强制在线的情况必须使用动态开点.

关键字:懒标记,开点,插入，查询,自定义结构体

```java
class MyCalendar {
    class Node {
        // ls 和 rs 分别代表当前节点的左右子节点在 tr 的下标
        // val 代表当前节点有多少数
        // add 为懒标记
        int ls, rs, add, val;
    }
    int N = (int)1e9, M = 120010, cnt = 1;
    Node[] tr = new Node[M];
    void update(int u, int lc, int rc, int l, int r, int v) {
        if (l <= lc && rc <= r) {
            tr[u].val += (rc - lc + 1) * v;
            tr[u].add += v;
            return ;
        }
        lazyCreate(u);
        pushdown(u, rc - lc + 1);
        int mid = lc + rc >> 1;
        if (l <= mid) update(tr[u].ls, lc, mid, l, r, v);
        if (r > mid) update(tr[u].rs, mid + 1, rc, l, r, v);
        pushup(u);
    }
    int query(int u, int lc, int rc, int l, int r) {
        if (l <= lc && rc <= r) return tr[u].val;
        lazyCreate(u);
        pushdown(u, rc - lc + 1);
        int mid = lc + rc >> 1, ans = 0;
        if (l <= mid) ans = query(tr[u].ls, lc, mid, l, r);
        if (r > mid) ans += query(tr[u].rs, mid + 1, rc, l, r);
        return ans;
    }
    void lazyCreate(int u) {
        if (tr[u] == null) tr[u] = new Node();
        if (tr[u].ls == 0) {
            tr[u].ls = ++cnt;
            tr[tr[u].ls] = new Node();
        }
        if (tr[u].rs == 0) {
            tr[u].rs = ++cnt;
            tr[tr[u].rs] = new Node();
        }
    }
    void pushdown(int u, int len) {
        tr[tr[u].ls].add += tr[u].add; tr[tr[u].rs].add += tr[u].add;
        tr[tr[u].ls].val += (len - len / 2) * tr[u].add; tr[tr[u].rs].val += len / 2 * tr[u].add;
        tr[u].add = 0;
    }
    void pushup(int u) {
        tr[u].val = tr[tr[u].ls].val + tr[tr[u].rs].val;
    }
    public boolean book(int start, int end) {
        if (query(1, 1, N + 1, start + 1, end) > 0) return false;
        update(1, 1, N + 1, start + 1, end, 1);
        return true;
    }
}
```







对于本题属于非强制在线的情况，方式一见:933最近的请求次数

我们使用动态开点

具体的，我们将顺序放置方块的操作（假设当前方块的左端点为 aaa，边长为 lenlenlen，则有右端点为 b=a+lenb = a + lenb=a+len），分成如下两步进行：

    查询当前范围 [a,b][a, b][a,b] 的最大高度为多少，假设为 curcurcur；
    更新当前范围 [a,b][a, b][a,b] 的最新高度为 cur+lencur + lencur+len。

因此这本质上是一个「区间修改 + 区间查询」的问题，我们需要实现带「懒标记」的线段树，从而确保在进行「区间修改」时复杂度仍为 O(log⁡n)O(\log{n})O(logn)。

```java
class Solution {
    class Node {
        // ls 和 rs 分别代表当前区间的左右子节点所在 tr 数组中的下标
        // val 代表当前区间的最大高度，add 为懒标记
        int ls, rs, val, add;
    }
    int N = (int)1e9, cnt = 0;
    Node[] tr = new Node[1000010];
    void update(int u, int lc, int rc, int l, int r, int v) {
        if (l <= lc && rc <= r) {
            tr[u].val = v;
            tr[u].add = v;
            return ;
        }
        pushdown(u);
        int mid = lc + rc >> 1;
        if (l <= mid) update(tr[u].ls, lc, mid, l, r, v);
        if (r > mid) update(tr[u].rs, mid + 1, rc, l, r, v);
        pushup(u);
    }
    int query(int u, int lc, int rc, int l, int r) {
        if (l <= lc && rc <= r) return tr[u].val;
        pushdown(u);
        int mid = lc + rc >> 1, ans = 0;
        if (l <= mid) ans = query(tr[u].ls, lc, mid, l, r);
        if (r > mid) ans = Math.max(ans, query(tr[u].rs, mid + 1, rc, l, r));
        return ans;
    }
    void pushdown(int u) {
        if (tr[u] == null) tr[u] = new Node();
        if (tr[u].ls == 0) {
            tr[u].ls = ++cnt;
            tr[tr[u].ls] = new Node();
        }
        if (tr[u].rs == 0) {
            tr[u].rs = ++cnt;
            tr[tr[u].rs] = new Node();
        }
        if (tr[u].add == 0) return ;
        int add = tr[u].add;
        tr[tr[u].ls].add = add; tr[tr[u].rs].add = add;
        tr[tr[u].ls].val = add; tr[tr[u].rs].val = add;
        tr[u].add = 0;
    }
    void pushup(int u) {
        tr[u].val = Math.max(tr[tr[u].ls].val, tr[tr[u].rs].val);
    }
    public List<Integer> fallingSquares(int[][] ps) {
        List<Integer> ans = new ArrayList<>();
        tr[1] = new Node();
        for (int[] info : ps) {
            int x = info[0], h = info[1], cur = query(1, 1, N, x, x + h - 1);
            update(1, 1, N, x, x + h - 1, cur + h);
            ans.add(tr[1].val);
        }
        return ans;
    }
}
```

### 5.27

刷蓝桥杯

### 5.28

14.最长公共前缀

循环处理1

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
    String prefix=strs[0];
        for (int i = 0; i < strs.length; i++) {
            prefix=process(prefix,strs[i]);
        }
        return prefix;
    }
    public String process(String prefix,String str){
            int n=Math.min(prefix.length(),str.length());
            String ans="";
        for (int i = 0; i < n; i++) {
            if(prefix.charAt(i)!=str.charAt(i)){
                return ans;
            }
            ans+=prefix.charAt(i);
        }
        return ans;
    }
}
```

```java
    class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        int count = strs.length;
        for (int i = 1; i < count; i++) {
            prefix = longestCommonPrefix(prefix, strs[i]);
            if (prefix.length() == 0) {
                break;
            }
        }
        return prefix;
    }

    public String longestCommonPrefix(String str1, String str2) {
        int length = Math.min(str1.length(), str2.length());
        int index = 0;
        while (index < length && str1.charAt(index) == str2.charAt(index)) {
            index++;
        }
        return str1.substring(0, index);
    }
}

```

循环+判断

```java
        public String longestCommonPrefix(String[] strs) {
        for (int i = 0; i < strs[0].length(); i++) {
            char c=strs[0].charAt(i);
            for (int j = 1; j < strs.length; j++) {
                if(i==strs[j].length()||strs[j].charAt(i)!=c){
                    return strs[0].substring(0,i);
                }
            }
        }
        return strs[0];
    }
```

20.有效的括号

```java
class Solution {
        public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        HashMap<Character, Character> map = new HashMap<>();
        map.put('}','{');
        map.put(')','(');
        map.put(']','[');
        for (int i = 0; i < s.length(); i++) {
            if(map.containsKey(s.charAt(i))) {
                if (!stack.isEmpty() && stack.peek() == map.get(s.charAt(i))) {
                    stack.pop();
                }else {
                    return false;
                }
            }else{
                stack.add(s.charAt(i));
            }
        }
        return stack.isEmpty();
    }
}
```

```java
class Solution {
        public boolean isPalindrome(int x) {
            if(x<0){
                return false;
            }
        String s = String.valueOf(x);
        int l=0;
        int r=s.length()-1;
        while(l<=r&&s.charAt(l)==s.charAt(r)){
            l++;
            r--;
        }
        return s.length()%2==0?l-r==1:l-r==2;
    }
}
```

每日一题

1021.删除最外层的括号

```java
    class Solution {
    public String removeOuterParentheses(String s) {
        StringBuffer res = new StringBuffer();
        Deque<Character> stack = new ArrayDeque<Character>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == ')') {
                stack.pop();
            }
            //没想到这一判断，最外层就是stack不为空的时候.
            if (!stack.isEmpty()) {
                res.append(c);
            }
            if (c == '(') {
                stack.push(c);
            }
        }
        return res.toString();
    }
}

```

