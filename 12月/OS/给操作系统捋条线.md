

#### Bootloader:

实模式如何到保护模式？

如何开启分页机制？

逻辑地址，虚拟地址，线性地址，物理地址如何转化的？

如何读取磁盘加载内核？

多处理器的话又是如何启动的？

#### 中断与系统调用：

两者的过程差不太多，只不过一个中断源来源于外部，一个来源内部，在内核部分，两者的处理过程基本一样，这一块儿大概有这些问题：

中断与异常的关系?

什么是软件中断?

软件中断和软中断是一个东西吗？

中断控制器PIC、APIC的基本认识？

多个处理器多种中断，哪个处理器处理哪个中断呢？

中断的处理过程

向量号，IDT，中断服务程序(如何定位中断服务程序)？

现场的保存与恢复到底什么意思？

发生中断期间栈是如何变化的？

系统调用大致过程?

系统调用时用户程序的参数如何传递给内核？

#### 文件系统：

将文件系统分为了7层，磁盘缓存日志目录路径文件描述符，大概有这些问题：•磁盘驱动程序(磁盘如何读写)？

•一个简单的日志系统如何设计？

•为什么日志系统能够保证数据的一致性？

•文件，目录，目录项，文件描述符，文件结构体它们之间到底什么关系？

•一切皆文件怎么理解，为什么，这两个系统调用就可以读写任意类型的文件？

•目录项，硬链接，软链接到底什么意思，有什么关系？•常见的文件系统调用比如如何实现的？#### 进程

•如何创建一个进程(实现)？

•第一个进程如何创建的？

•程序是如何从磁盘加载到内存的(实现)？

•一个进程如何被调度上？

•常见的调度算法及其利弊？

•进程如何切换(页表，，栈，上下文等是如何变化的)？

•进程的休眠唤醒如何实现？

•进程的等待退出如何实现？

•孤儿进程，僵尸进程什么意思？

•程序从开始执行(简单了解了解运行库)？

•堆到底是个什么玩意儿？

如何实现？如何组织管理？

#### 内存管理：

•的物理内存是如何管理的，虚拟内存又是如何管理的？

•虚拟地址空间应该如何理解？

•地址 0 真的就不能访问？

•所谓的分配内存做了些什么事

#### 锁：

•自旋锁如何设计？

•休眠锁如何设计？

•常见死锁判断控制台：

•键盘的简单认识

•显卡的简单认识

•串口的简单认识

•按下一个键到输出到屏幕这之间的详细过程？

•函数如何实现的

•为什么文件描述符 0、1  、2   就表示标准输入输出错误呢？

•如何实现的•重定向什么意思，如何实现？

•管道什么意思，如何实现？

•一些常用命令如、等等如何实现的？





实模式

0xffff0

0xf0000 1M 系统BIOS

0x7c00  MBR  bootblock

接下来的代码由操作系统掌控

xv6没有实际构造MBR结构，最开始那个扇区写入的是bootblock,由bootasm.S和bootmain.c两文件编译链接转换格式得来

makefile:

```makefile
bootblock:bootasm.S bootmain.c
################################
ddif=bootblock of=xv6.img conv=notrunc
```

![image-20221204123805590](https://raw.githubusercontent.com/lozijy/image/main/image-20221204123805590.png)

![image-20221204123841847](https://raw.githubusercontent.com/lozijy/image/main/image-20221204123841847.png)

bootasm.S：

做了一件事:进入保护模式,打开A20总线，构建加载GDT,设置CR0寄存器



使用键盘控制器打开A20总线

```assembly
seta20.1:# Wait for not busy 等待i8042缓冲区为空
inb$0x64,%al# 从0x64端口读出键盘状态
testb$0x2,%al# 测试键盘是否忙jnzseta20.1# 忙的话跳转到seta20.1，循环等待

movb$0xd1,%al # 发送0xd1到端口0x64，表示准备向0x60端口写入命令
outb%al,$0x64

seta20.2:
inb$0x64,%al# Wait for not busy  同上
testb$0x2,%al
jnzseta20.2

movb$0xdf,%al# 向端口0x60写入0xdf，打开A20
outb%al,$0x60

```

