interuption

来自intel手册第六章

CPU遇到中断它如何知道如何救场，用什么救？他不知道但哦我们知道，我们为每个中断写一个处理函数ISR(中断处理函数)，编成一个表IDT(中断描述表)

bios

ISR:某个由CPU直接调用的函数

IDT:和GDT差不多结构，都是一个64B的数组，每个描述符包含了指向ISR的指针和一些附加信息

描述符的索引:描述中断向量号

中断描述符的三种情况:由bits8-10决定是哪一种,Task Gate , Interrupt Gate , Trap Gata

![image-20221203230809876](https://raw.githubusercontent.com/lozijy/image/main/image-20221203230809876.png)





![image-20221203231116577](https://raw.githubusercontent.com/lozijy/image/main/image-20221203231116577.png)

安装idt:指令 lidt



编写代码:

![image-20221203231426558](https://raw.githubusercontent.com/lozijy/image/main/image-20221203231426558.png)

ISR

![image-20221203233023116](https://raw.githubusercontent.com/lozijy/image/main/image-20221203233023116.png)

![image-20221203233818389](https://raw.githubusercontent.com/lozijy/image/main/image-20221203233818389.png)

errorcode是否存在与否取决于当前产生的中断

![image-20221203234009342](https://raw.githubusercontent.com/lozijy/image/main/image-20221203234009342.png)

ISR不是C函数，因为C函数编译成.S汇编后都是以ret结尾的，但是ISR要求以IRET结尾

![image-20221203234107569](https://raw.githubusercontent.com/lozijy/image/main/image-20221203234107569.png)



IRET vs RET?

![image-20221203234411274](https://raw.githubusercontent.com/lozijy/image/main/image-20221203234411274.png)

iret假定error code不存在



1.内联汇编注入iret,不行

![image-20221204000728877](https://raw.githubusercontent.com/lozijy/image/main/image-20221204000728877.png)

2.同时注入leave,可以，但这是假设errorcode不存在.

![image-20221204000917829](https://raw.githubusercontent.com/lozijy/image/main/image-20221204000917829.png)