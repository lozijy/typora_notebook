## 前言

## lab1

使用系统调用在user文件夹里写一些函数

## lab2

### trace

![image-20221204145443709](https://raw.githubusercontent.com/lozijy/image/main/image-20221204145443709.png)

lab1通过系统调用完成了一些功能，现在我们要自己拓展一些系统调用，完成前请阅读riscv手册,xv6手册《book-riscv-rev1》第2章，第4章的4.3节，4.4节，相关源代码文件

系统调用的用户空间代码 user/user.h和user/usys.pl

内核空间代码 kernel/syscall.h 和 kernel/syscall.c

与进程相关的代码:kernel/proc.h和kernel/proc.c

开始实验前吧代码切换到syscall分支

makefile

```makefile
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_trace\
	$U/_sysinfotest\
```

kernel/proc.c

```c
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  int trace_mask;              // 用于实现trace的掩码
};
```

kernel/sysproc.c

```c
uint64
sys_trace(void) {
  // argint检索的是第n个系统调用的参数，因此不包括系统调用本身，传入的参数为0
  argint(0, &(myproc()->trace_mask));
  return 0;
}
```



kernel/syscall.c

```c
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
[SYS_kill]    sys_kill,
[SYS_exec]    sys_exec,
[SYS_fstat]   sys_fstat,
[SYS_chdir]   sys_chdir,
[SYS_dup]     sys_dup,
[SYS_getpid]  sys_getpid,
[SYS_sbrk]    sys_sbrk,
[SYS_sleep]   sys_sleep,
[SYS_uptime]  sys_uptime,
[SYS_open]    sys_open,
[SYS_write]   sys_write,
[SYS_mknod]   sys_mknod,
[SYS_unlink]  sys_unlink,
[SYS_link]    sys_link,
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_trace]   sys_trace,
[SYS_sysinfo] sys_sysinfo,
};

const char *syscallname[] = {
[SYS_fork]    "fork",
[SYS_exit]    "exit",
[SYS_wait]    "wait",
[SYS_pipe]    "pipe",
[SYS_read]    "read",
[SYS_kill]    "kill",
[SYS_exec]    "exec",
[SYS_fstat]   "fstat",
[SYS_chdir]   "chdir",
[SYS_dup]     "dup",
[SYS_getpid]  "getpid",
[SYS_sbrk]    "sbrk",
[SYS_sleep]   "sleep",
[SYS_uptime]  "uptime",
[SYS_open]    "open",
[SYS_write]   "write",
[SYS_mknod]   "mknod",
[SYS_unlink]  "unlink",
[SYS_link]    "link",
[SYS_mkdir]   "mkdir",
[SYS_close]   "close",
[SYS_trace]   "trace",
[SYS_sysinfo] "sysinfo",
};

void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7; // 在initcode.S中可以看到a7中存放了系统调用对应的数字
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num](); // 在函数指针数组syscalls中索引对应的系统调用，a0被约定用于存放返回值，这句代码实际执行了系统调用
    // 打印追踪信息
    if ((1 << num) & (p->trace_mask))
      printf("%d: syscall %s -> %d\n", p->pid, syscallname[num], p->trapframe->a0);
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}

```

### sysinfo

1.写一个函数获取空闲内存大小

riscv.h

```c
#define PGSIZE 4096 // bytes per page页的大小4KB
```

kernel/kalloc.c

获取空闲内存,内存是使用链表进行管理的，因此遍历`kmem`中的空闲链表就能够获取所有的空闲内存，如下

```c
struct run {
  struct run *next;
};

struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;
// 获取剩余内存字节数
uint64
freebytes(void) {
  uint64 bytes = 0;
  struct run *p = kmem.freelist;  // 遍历指针

  acquire(&kmem.lock);
  while(p) {
    bytes += PGSIZE;
    p = p->next;
  }
  release(&kmem.lock);

  return bytes;
}
```



2.写一个函数获取活跃的线程数量

kernel/param.h

```c
#define NPROC        64  // maximum number of processes
```

kernel/proc.c

```c
struct proc proc[NPROC];

// 获取进程数
uint64
procnum(void) {
  int np = 0;
  struct proc *p;
  for(p = proc; p < &proc[NPROC]; ++p) {
    // p->lock must be held when using state
    acquire(&p->lock);
    if(p->state != UNUSED) 
      ++np;
    release(&p->lock);
  }
  return np;
}
```

3.实现sys_sysinfo

kernel/sysproc

```c
extern uint64 freebytes(void);
extern uint64 procnum(void);
uint64
sys_sysinfo(void){
  // 暂存系统信息
  struct sysinfo info;
  info.freemem = freebytes();
  info.nproc = procnum();

  // 获取虚拟地址
  uint64 destaddr;
  argaddr(0,&destaddr);

  // 从kernel拷贝到user
  if(copyout(myproc()->pagetable, destaddr, (char*)&info, sizeof info) < 0)
    return -1;

  return 0;
}
```

获取虚拟地址:

大概就是把这个进程的寄存器a0中的值放进ip中

```c
static uint64
argraw(int n)
{
  struct proc *p = myproc();
  switch (n) {
  case 0:
    return p->trapframe->a0;
  case 1:
    return p->trapframe->a1;
  case 2:
    return p->trapframe->a2;
  case 3:
    return p->trapframe->a3;
  case 4:
    return p->trapframe->a4;
  case 5:
    return p->trapframe->a5;
  }
  panic("argraw");
  return -1;
}
int
argaddr(int n, uint64 *ip)
{
  *ip = argraw(n);
  return 0;
}

```



kernel/vm.c

从内核空间复制到用户空间，输入页表，虚拟地址，字符串,大小

```c
// Copy from kernel to user.
// Copy len bytes from src to virtual address dstva in a given page table.
// Return 0 on success, -1 on error.
int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
{
  uint64 n, va0, pa0;

  while(len > 0){
    va0 = PGROUNDDOWN(dstva);
    pa0 = walkaddr(pagetable, va0);
    if(pa0 == 0)
      return -1;
    n = PGSIZE - (dstva - va0);
    if(n > len)
      n = len;
    memmove((void *)(pa0 + (dstva - va0)), src, n);

    len -= n;
    src += n;
    dstva = va0 + PGSIZE;
  }
  return 0;
}

```



kernel/syscall.h

```c
#define SYS_sysinfo 23
```

kernel/syscall.c

```c
extern uint64 sys_sysinfo(void);
```



## b3

![image-20221204145512319](https://raw.githubusercontent.com/lozijy/image/main/image-20221204145512319.png)

