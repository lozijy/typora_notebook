

#### Bootloader:

实模式如何到保护模式？

如何开启分页机制？

逻辑地址，虚拟地址，线性地址，物理地址如何转化的？

如何读取磁盘加载内核？

多处理器的话又是如何启动的？

#### 中断与系统调用：

两者的过程差不太多，只不过一个中断源来源于外部，一个来源内部，在内核部分，两者的处理过程基本一样，这一块儿大概有这些问题：

中断与异常的关系?

什么是软件中断?

软件中断和软中断是一个东西吗？

中断控制器PIC、APIC的基本认识？

多个处理器多种中断，哪个处理器处理哪个中断呢？

中断的处理过程

向量号，IDT，中断服务程序(如何定位中断服务程序)？

现场的保存与恢复到底什么意思？

发生中断期间栈是如何变化的？

系统调用大致过程?

系统调用时用户程序的参数如何传递给内核？

#### 文件系统：

将文件系统分为了7层，磁盘缓存日志目录路径文件描述符，大概有这些问题：•磁盘驱动程序(磁盘如何读写)？

•一个简单的日志系统如何设计？

•为什么日志系统能够保证数据的一致性？

•文件，目录，目录项，文件描述符，文件结构体它们之间到底什么关系？

•一切皆文件怎么理解，为什么，这两个系统调用就可以读写任意类型的文件？

•目录项，硬链接，软链接到底什么意思，有什么关系？•常见的文件系统调用比如如何实现的？#### 进程

•如何创建一个进程(实现)？

•第一个进程如何创建的？

•程序是如何从磁盘加载到内存的(实现)？

•一个进程如何被调度上？

•常见的调度算法及其利弊？

•进程如何切换(页表，，栈，上下文等是如何变化的)？

•进程的休眠唤醒如何实现？

•进程的等待退出如何实现？

•孤儿进程，僵尸进程什么意思？

•程序从开始执行(简单了解了解运行库)？

•堆到底是个什么玩意儿？

如何实现？如何组织管理？

#### 内存管理：

•的物理内存是如何管理的，虚拟内存又是如何管理的？

•虚拟地址空间应该如何理解？

•地址 0 真的就不能访问？

•所谓的分配内存做了些什么事

#### 锁：

•自旋锁如何设计？

•休眠锁如何设计？

•常见死锁判断控制台：

•键盘的简单认识

•显卡的简单认识

•串口的简单认识

•按下一个键到输出到屏幕这之间的详细过程？

•函数如何实现的

•为什么文件描述符 0、1  、2   就表示标准输入输出错误呢？

•如何实现的•重定向什么意思，如何实现？

•管道什么意思，如何实现？

•一些常用命令如、等等如何实现的？





实模式

0xffff0

0xf0000 1M 系统BIOS

0x7c00  MBR  bootblock

接下来的代码由操作系统掌控

xv6没有实际构造MBR结构，最开始那个扇区写入的是bootblock,由bootasm.S和bootmain.c两文件编译链接转换格式得来

makefile:

```makefile
bootblock:bootasm.S bootmain.c
################################
ddnif=bootblock of=xv6.img conv=notrunc
```

![image-20221204123805590](https://raw.githubusercontent.com/lozijy/image/main/image-20221204123805590.png)

![image-20221204123841847](https://raw.githubusercontent.com/lozijy/image/main/image-20221204123841847.png)

bootasm.S：

做了一件事:进入保护模式,打开A20总线，构建加载GDT,设置CR0寄存器



使用键盘控制器打开A20总线

```assembly
seta20.1:# Wait for not busy 等待i8042缓冲区为空
inb$0x64,%al# 从0x64端口读出键盘状态
testb$0x2,%al# 测试键盘是否忙jnzseta20.1# 忙的话跳转到seta20.1，循环等待

movb$0xd1,%al # 发送0xd1到端口0x64，表示准备向0x60端口写入命令
outb%al,$0x64

seta20.2:
inb$0x64,%al# Wait for not busy  同上
testb$0x2,%al
jnzseta20.2

movb$0xdf,%al# 向端口0x60写入0xdf，打开A20
outb%al,$0x60

```

# 启动理论

## 实模式下的内存分布

实模式下线性地址就是物理地址，由于没有开启A20总线，寻址能力只有1MB，内存分布如下:

![image-20221205000116510](https://raw.githubusercontent.com/lozijy/image/main/image-20221205000116510.png)

关注最高位和7C00即可

一个是BIOS入口地址，一个是MBR加载地址

## 物理地址和物理地址空间

1.

![image-20221205000353302](https://raw.githubusercontent.com/lozijy/image/main/image-20221205000353302.png)

2.

![image-20221205000409458](https://raw.githubusercontent.com/lozijy/image/main/image-20221205000409458.png)

## 实模式和保护模式

实模式:

寻址能力20

寄存器只用了16位，寻址能力16

所以用段基址:偏移量的分段方式使cpu寻址能力为20

寄存器里存的是真实的物理地址，不安全，也不灵活



## 保护模式

地址总线32位

通用寄存器，标志寄存器，指令指针寄存器拓展到32位，段寄存器不变

引入GDT,现在寄存器里存放的是段选择子而非段基址，访问变安全了

## GDT

段描述符

![image-20221205001316809](https://raw.githubusercontent.com/lozijy/image/main/image-20221205001316809.png)

基址被映射成三部分

DPL 描述符特权级 0最高 3最低



段选择子

![image-20221205001610479](https://raw.githubusercontent.com/lozijy/image/main/image-20221205001610479.png)

寄存器里存的就是这玩意，每个进程都有一个，index是高13位，通过这个+GDT可以找到段基址，用过这个13我们可以确定共有2<<13 -1共8192个段

RPL请求特权级，4个值0,1,2,3，主要用来进行特权级检查

段级地址转换

![image-20221205002030294](https://raw.githubusercontent.com/lozijy/image/main/image-20221205002030294.png)

逻辑地址转换成线性地址的方法



## 控制寄存器

CR0

PE: 1表示保护模式

PG 1表示开启分页

CR1

CR2

CR3

CR4

PSE位 1表示页面大小拓展为4M



## 特权级

![image-20221205002544874](https://raw.githubusercontent.com/lozijy/image/main/image-20221205002544874.png)

0内核态

1用户态

![image-20221205002810933](https://raw.githubusercontent.com/lozijy/image/main/image-20221205002810933.png)

## 保护模式

开启A20总线

构建加载GDT

设置CR0的PE位



## 分页

分段是必须的，分页不是必须的

## 一级页表和多级页表

## 开启分页机制

构建页表

加载页目录物理地址到CR3寄存器

## 各类地址

逻辑地址

线性地址

虚拟地址

物理地址

## 地址转换

1.段级转换

2.页级转换

## 平坦模式

## 页面大小拓展

CR4寄存器的PSE位置1

把页面大小设置为1M

## ELF文件格式

文件布局

文件头

## 启动流程简要介绍

## 

## 中断控制器PIC

## 

## 

## 

## 

## 

## 

## 

## 



