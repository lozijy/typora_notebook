## 计算机基础知识

### 汇编语言

### 存储器

### 指令和数据

### CPU对存储器的读写

### 地址总线

### 数据总线

## 【BX】和loop指令

loop:

```assembly
assume cs:code
code segment
	mov ax,2
	mov cx,11
s: add ax,ax
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```

loop和[BX]联合使用实现

计算ffff:0 到ffff:b单元中的数据的和，结果存储在dx中，?能直接把内存中的数加到寄存器里吗?

```assembly
assume cs:code
code segment
	mov ax,ffff
	mov ds,ax
	mov bx,0
	mov cx,11
	mov dx,ds:[bx]
s:	inc bx
	add dx,ds:[bx]
code ends
end
```

```assembly
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov bx,0
	mov dx,0
	moc cx,12
s:	mov al,[bx]
	mov ah,0
	add dx,ax
	inc bx
	loop s
	
	mov ax,4c00h
	int 21h
code ends
end
```

在dos模式下

## 包含多个段的程序D

```assembly
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	mov bx,0
	mov ax,0
	mov cx,8
s:	add ax,cs:[bx]
	add bx,2
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```

dw即"define word"定义一个字型数据

```assembly
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	start:	mov bx,0
			mov ax,0
			mov cx,8
	s:		add ax,cs:[bx]
			add bx,2
			loop s
			mov ax,4c00h
			int 21h
code ends
end start
```

end的作用除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方

```assembly
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
										;用dw定义了16个字型数据，在程序加载后，将取得16个字的内存空间，存放这16个数据，在后面的程序中将这段空间当做栈来用
	start:	mov bx,0
			mov ax,0
			mov cx,8
	s:		add ax,cs:[bx]
			add bx,2
			loop s
			mov ax,4c00h
			int 21h
code ends
end start
```

我们首先要有一段可用作栈的内存空间，如前面所说，这段空间应该由系统来分配，然后将这段空间当做栈空间来用

## 更灵活的定位内存地址的方法

## 数据处理的两个基本问题

### bx,si,di,bp

### 机器指令处理的数据在什么地方

### 汇编语言中数据位置的表达

### 寻址方式

### 指令处理的数据有多长

### 寻址方式的综合应用

### div指令

### 伪指令dd

### dup

## 转移指令的原理

### offset

### jmp

### 近跳

### 远跳

### 转移地址在寄存器和在内存中的jmp

### jcxz指令

### loop指令

### 根据位移进行转移的意义

### 编译器对转移位移越界的检测



## CALL和RET指令

### ret和retf

### call

### 近call

### 远call

### 转移地址在寄存器和在内存中的call

### call和ret的配合使用

### mul

### 模块化程序

### 参数和结果传递

### 批量数据的传输

### 寄存器冲突

## 标志寄存器

### ZF

### PF

### SF

### CF

### OF

### adc指令

### sbb指令

### cmp指令

### 检测比较结果的条件转移指令

### DF标志和串传送指令

### pushf和popf



## 内中断

中断信息是要求CPU马上进行某种处理，并向所要进行的某种处理提供必备的参数的通知信息

### 内中断的产生

1.除法错误

2.单步执行

3.执行into指令

4.执行int指令

CPU首先要知道所接受到的中断信息的来源，所以中断信息必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。8086CPU中的中断类型码如下:

除法错误:0

单步执行:1

执行into指令:4

执行int指令:指令格式是int n,指令中的n为字节型立即数，是提供给CPU的中断类型码

### 中断处理程序

CPU在收到中断信息后，转去该中断信息的处理程序，将CS:IP指向它的入口，那么CPU收到中断信息后如何根据中断信息确定其处理程序的入口？CPU设计者在中断信息和处理程序间建立一种联系，使CPU根据中断信息可以找到处理程序的CS和IP

### 中断向量表

中断向量：中断处理程序的入口地址

中断向量表：中断处理程序入口地址的列表

中断向量表在内存中常驻，存放256个中断源所对应的中断处理程序的入口地址。

一个首要的问题是：CPU如何找到中断向量表？对于8086PC机，中断向量表制定放在内存地址0处。从地址0000：0000到0000：03FF的1024个单元存放中断向量表。

在中断向量表中一个表项就是一个中断向量，包括段地址和偏移地址。所以一个表项占用2个字，高地址存放段地址，低地址存放偏移地址。

### 中断过程

CPU收到中断信息后首先引发中断过程，硬件完成中断过程后，CS:IP指向中断处理程序的入口，CPU开始执行中断处理程序。

值得注意的是，CPU完成中断处理程序后会返回到原来的执行点继续执行下面的指令。所以中断过程中，设置CS:IP前要将原来的CS和IP的值保存起来。

下面是8086CPU收到中断信息后引发的中断过程：

1.获取中断类型码

2.标志寄存器的值入栈

3.设置标志寄存器第八位TF和第九位IF的值为0

4.CS的内容入栈

5.IP的内容入栈

6.从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS

1.获取中断类型码N；

2.pushf

3.TF=0,IF=0

4.push CS

5.push IP

6.(IP)=(N*4),(CS)=(N\*4+2)

### 中断处理程序和iret指令

中断处理程序常驻内存

编写方法和子程序类似

1.保存用到的寄存器

2.处理中断

3.恢复用到的寄存器

4.用iret指令返回

iret：

pop IP

pop CS

popf

### 编程处理0号中断

#### 要求：

mov ax,1000h

mov bh,1

div bh

CPU执行div bh时，发生除法溢出错误，从而引发中断过程，CPU执行0号中断处理程序，从而引发中断过程，CPU执行0号中断处理程序。显示提示信息:"Divide overflow"后返回到操作系统

#### 分析

一.除法溢出后CPU进行以下工作

1.获取中断类型码0

2.标志寄存器入栈，TF,IF设置为0

3.CS，IP入栈

4.IP=（0*4），CS=(0\*4+2)

二.显示overflow的中断处理程序

1.相关处理

2.向显示缓冲区送字符串"overflow!";

3.返回DOS

把这段程序称为do0

三.do0应该放在哪里？

我们把do0凡在别的程序不会用到的内存区，将do0放在其中即可

0000：0000~0000:03FF大小为1KB的空间存放中断向量表，支持256个中断，但实际上系统中的中断事件远没有256个。操作系统一般不会使用中断向量表的内存，所以我们可以在空闲空间里放do0，我们把do0放在内存0000:0200处。

#### 程序框架

```assembly
assume cs:code
code segment
start: 	do0安装程序
		设置中断向量表
		mov ax,4c00h
		int 21h
do0:	显示字符串"overflow!"
		mov ax,4c00h
		int 21h
code ends
end start
```

1.安装do0

将do0的代码复制到内存0:200处，可以使用movsb指令，将do0的代码送到0:200处

```assembly
设置es:di指向目的地址
设置ds:si指向源地址
设置cx为传输长度
设置传输方向为正
rep movsb
```

原始地址:段地址code,偏移地址: offset do0;

目的地址：0:200

传输长度:do0部分代码的长度

传输方向:正向

```assembly
mov ax,cs
mov ds,ax
mov si,offset do0

mov ax,0
mov es,ax
mov di,200h

mov cx,do0部分代码的长度

cld;设置传输方向为正
rep movsb
```

如何知道do0代码的长度?设置一个占位nop作为do0end

```assembly
mov cx,offset do0end-offset do0

do0:xxx
do0end:nop
```



2.do0程序

"overflow!"如果在程序段中，则执行完后会返回空间会释放，可能会被别的信息覆盖，因此我们应该将"overflow!"存放在一段不会被覆盖的空间中

```assembly
do0:jmp short do0start
	db "overflow!"
	
do0start:	mov ax,cs
			mov ds,ax
			mov si,202h
			
			mov ax,0b800h
			mov es,ax
			mov di,12*160+26*2;es:di指向显存空间的中间位置
			
			mov cx,9
s:			mov al,[si]
			mov es:[di],al
			inc si
			add di,2
			loop s
			
			mov ax,4c00h
			int 21h
			
			
			
			
	
	
```

#### 设置中断向量

## int 指令

一种重要的内中断，由int指令引发的中断

执行过程:

1.取中断类型码n

2.标志寄存器入栈，IF=0,TF=0;

3.CS,IP入栈

4.IP=(N*4),CS=(N\*4+2)

使用int 0指令将会触发中断过程并执行0号中断处理程序，int指令的功能和call指令类似，都是调用一段程序

### 编写供应用程序调用的中断例程

```assembly
```



### 对int,iret和栈的深入理解

### BIOS和DOS提供的中断例程

### BIOS和DOS中断例程的安装过程

### BIOS中断例程应用

## 端口

## 外中断

## 直接定址表

## 使用BIOS进行键盘读写和磁盘读写

## 综合研究

